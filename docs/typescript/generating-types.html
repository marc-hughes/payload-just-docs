<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Generating TypeScript Interfaces</h1><p class="text-xl text-gray-600 mb-8">Generate your own TypeScript interfaces based on your collections and globals.</p><div class="prose prose-lg max-w-none"><p>While building your own custom functionality into Payload, like <a href="../plugins/overview">Plugins</a>, <a href="../hooks/overview">Hooks</a>, <a href="../access-control/overview">Access Control</a> functions, <a href="../custom-components/custom-views">Custom Views</a>, <a href="../graphql/overview">GraphQL queries / mutations</a>, or anything else, you may benefit from generating your own TypeScript types dynamically from your Payload Config itself.</p>
<h2>Types generation script</h2>
<p>Run the following command in a Payload project to generate types based on your Payload Config:</p>
<pre><code>payload generate:types
</code></pre>
<p>You can run this command whenever you need to regenerate your types, and then you can use these types in your Payload code directly.</p>
<h2>Disable declare statement</h2>
<p>By default, <code>generate:types</code> will add a <code>declare</code> statement to your types file, which automatically enables type inference within Payload.</p>
<p>If you are using your <code>payload-types.ts</code> file in other repos, though, it might be better to disable this <code>declare</code> statement, so that you don&#x27;t get any TS errors in projects that use your Payload types, but do not have Payload installed.</p>
<pre><code class="language-ts">// payload.config.ts
{
  // ...
  typescript: {
    declare: false, // defaults to true if not set
  },
}
</code></pre>
<p>If you do disable the <code>declare</code> pattern, you&#x27;ll need to manually add a <code>declare</code> statement to your code in order for Payload types to be recognized. Here&#x27;s an example showing how to declare your types in your <code>payload.config.ts</code> file:</p>
<pre><code class="language-ts">import { Config } from &#x27;./payload-types&#x27;

declare module &#x27;payload&#x27; {
  export interface GeneratedTypes extends Config {}
}
</code></pre>
<h2>Custom output file path</h2>
<p>You can specify where you want your types to be generated by adding a property to your Payload Config:</p>
<pre><code class="language-ts">// payload.config.ts
{
  // ...
	typescript: {
    // defaults to: path.resolve(__dirname, &#x27;./payload-types.ts&#x27;)
		outputFile: path.resolve(__dirname, &#x27;./generated-types.ts&#x27;),
	},
}
</code></pre>
<p>The above example places your types next to your Payload Config itself as the file <code>generated-types.ts</code>.</p>
<h2>Custom generated types</h2>
<p>Payload generates your types based on a JSON schema. You can extend that JSON schema, and thus the generated types, by passing a function to <code>typescript.schema</code>:</p>
<pre><code class="language-ts">// payload.config.ts
{
  // ...
  typescript: {
    schema: [
      ({ jsonSchema }) =&gt; {
        // Modify the JSON schema here
        jsonSchema.definitions.Test = {
          type: &#x27;object&#x27;,
          properties: {
            title: { type: &#x27;string&#x27; },
            content: { type: &#x27;string&#x27; },
          },
          required: [&#x27;title&#x27;, &#x27;content&#x27;],
        }
        return jsonSchema
      },
    ]
  }
}

// This will generate the following type in your payload-types.ts:

export interface Test {
  title: string
  content: string
  [k: string]: unknown
}
</code></pre>
<p>This function takes the existing JSON schema as an argument and returns the modified JSON schema. It can be useful for plugins that wish to generate their own types.</p>
<h2>Example Usage</h2>
<p>For example, let&#x27;s look at the following simple Payload Config:</p>
<pre><code class="language-ts">import type { Config } from &#x27;payload&#x27;

const config: Config = {
  serverURL: process.env.NEXT_PUBLIC_SERVER_URL,
  admin: {
    user: &#x27;users&#x27;,
  },
  collections: [
    {
      slug: &#x27;users&#x27;,
      fields: [
        {
          name: &#x27;name&#x27;,
          type: &#x27;text&#x27;,
          required: true,
        },
      ],
    },
    {
      slug: &#x27;posts&#x27;,
      admin: {
        useAsTitle: &#x27;title&#x27;,
      },
      fields: [
        {
          name: &#x27;title&#x27;,
          type: &#x27;text&#x27;,
        },
        {
          name: &#x27;author&#x27;,
          type: &#x27;relationship&#x27;,
          relationTo: &#x27;users&#x27;,
        },
      ],
    },
  ],
}
</code></pre>
<p>By generating types, we&#x27;ll end up with a file containing the following two TypeScript interfaces:</p>
<pre><code class="language-ts">export interface User {
  id: string
  name: string
  email?: string
  resetPasswordToken?: string
  resetPasswordExpiration?: string
  loginAttempts?: number
  lockUntil?: string
}

export interface Post {
  id: string
  title?: string
  author?: string | User
}
</code></pre>
<h2>Custom Field Interfaces</h2>
<p>For <code>array</code>, <code>block</code>, <code>group</code> and named <code>tab</code> fields, you can generate top level reusable interfaces. The following group field config:</p>
<pre><code class="language-ts">{
  type: &#x27;group&#x27;,
  name: &#x27;meta&#x27;,
  interfaceName: &#x27;SharedMeta&#x27;, &lt;-- here!!
  fields: [
    {
      name: &#x27;title&#x27;,
      type: &#x27;text&#x27;,
    },
    {
      name: &#x27;description&#x27;,
      type: &#x27;text&#x27;,
    },
  ],
}
</code></pre>
<p>will generate:</p>
<pre><code class="language-ts">// a top level reusable interface!!
export interface SharedMeta {
  title?: string
  description?: string
}

// example usage inside collection interface
export interface Collection1 {
  // ...other fields
  meta?: SharedMeta
}
</code></pre>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p><strong>Naming Collisions</strong></p><p>Since these types are hoisted to the top level, you need to be aware that naming collisions can
occur. For example, if you have a collection with the name of <code>Meta</code> and you also create a
interface with the name <code>Meta</code> they will collide. It is recommended to scope your interfaces by
appending the field type to the end, i.e. <code>MetaGroup</code> or similar.</p></div>
<h2>Using your types</h2>
<p>Now that your types have been generated, Payload&#x27;s Local API will now be typed. It is common for users to want to use this in their frontend code, we recommend generating them with Payload and then copying the file over to your frontend codebase. This is the simplest way to get your types into your frontend codebase.</p>
<h3>Adding an npm script</h3>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p><strong>Important</strong></p><p>Payload needs to be able to find your config to generate your types.</p></div>
<p>Payload will automatically try and locate your config, but might not always be able to find it. For example, if you are working in a <code>/src</code> directory or similar, you need to tell Payload where to find your config manually by using an environment variable. If this applies to you, you can create an npm script to make generating your types easier.</p>
<p>To add an npm script to generate your types and show Payload where to find your config, open your <code>package.json</code> and update the <code>scripts</code> property to the following:</p>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;generate:types&quot;: &quot;PAYLOAD_CONFIG_PATH=src/payload.config.ts payload generate:types&quot;,
  },
}
</code></pre>
<p>Now you can run <code>pnpm generate:types</code> to easily generate your types.</p></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Generating TypeScript Interfaces","label":"Generating Types","order":20,"desc":"Generate your own TypeScript interfaces based on your collections and globals.","keywords":"headless cms, typescript, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"While building your own custom functionality into Payload, like \", _jsx(_components.a, {\n        href: \"../plugins/overview\",\n        children: \"Plugins\"\n      }), \", \", _jsx(_components.a, {\n        href: \"../hooks/overview\",\n        children: \"Hooks\"\n      }), \", \", _jsx(_components.a, {\n        href: \"../access-control/overview\",\n        children: \"Access Control\"\n      }), \" functions, \", _jsx(_components.a, {\n        href: \"../custom-components/custom-views\",\n        children: \"Custom Views\"\n      }), \", \", _jsx(_components.a, {\n        href: \"../graphql/overview\",\n        children: \"GraphQL queries / mutations\"\n      }), \", or anything else, you may benefit from generating your own TypeScript types dynamically from your Payload Config itself.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Types generation script\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Run the following command in a Payload project to generate types based on your Payload Config:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"payload generate:types\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can run this command whenever you need to regenerate your types, and then you can use these types in your Payload code directly.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Disable declare statement\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default, \", _jsx(_components.code, {\n        children: \"generate:types\"\n      }), \" will add a \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" statement to your types file, which automatically enables type inference within Payload.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are using your \", _jsx(_components.code, {\n        children: \"payload-types.ts\"\n      }), \" file in other repos, though, it might be better to disable this \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" statement, so that you don't get any TS errors in projects that use your Payload types, but do not have Payload installed.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// payload.config.ts\\n{\\n  // ...\\n  typescript: {\\n    declare: false, // defaults to true if not set\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you do disable the \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" pattern, you'll need to manually add a \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" statement to your code in order for Payload types to be recognized. Here's an example showing how to declare your types in your \", _jsx(_components.code, {\n        children: \"payload.config.ts\"\n      }), \" file:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { Config } from './payload-types'\\n\\ndeclare module 'payload' {\\n  export interface GeneratedTypes extends Config {}\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Custom output file path\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can specify where you want your types to be generated by adding a property to your Payload Config:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// payload.config.ts\\n{\\n  // ...\\n\\ttypescript: {\\n    // defaults to: path.resolve(__dirname, './payload-types.ts')\\n\\t\\toutputFile: path.resolve(__dirname, './generated-types.ts'),\\n\\t},\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above example places your types next to your Payload Config itself as the file \", _jsx(_components.code, {\n        children: \"generated-types.ts\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Custom generated types\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload generates your types based on a JSON schema. You can extend that JSON schema, and thus the generated types, by passing a function to \", _jsx(_components.code, {\n        children: \"typescript.schema\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// payload.config.ts\\n{\\n  // ...\\n  typescript: {\\n    schema: [\\n      ({ jsonSchema }) =\u003e {\\n        // Modify the JSON schema here\\n        jsonSchema.definitions.Test = {\\n          type: 'object',\\n          properties: {\\n            title: { type: 'string' },\\n            content: { type: 'string' },\\n          },\\n          required: ['title', 'content'],\\n        }\\n        return jsonSchema\\n      },\\n    ]\\n  }\\n}\\n\\n// This will generate the following type in your payload-types.ts:\\n\\nexport interface Test {\\n  title: string\\n  content: string\\n  [k: string]: unknown\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This function takes the existing JSON schema as an argument and returns the modified JSON schema. It can be useful for plugins that wish to generate their own types.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example Usage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, let's look at the following simple Payload Config:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Config } from 'payload'\\n\\nconst config: Config = {\\n  serverURL: process.env.NEXT_PUBLIC_SERVER_URL,\\n  admin: {\\n    user: 'users',\\n  },\\n  collections: [\\n    {\\n      slug: 'users',\\n      fields: [\\n        {\\n          name: 'name',\\n          type: 'text',\\n          required: true,\\n        },\\n      ],\\n    },\\n    {\\n      slug: 'posts',\\n      admin: {\\n        useAsTitle: 'title',\\n      },\\n      fields: [\\n        {\\n          name: 'title',\\n          type: 'text',\\n        },\\n        {\\n          name: 'author',\\n          type: 'relationship',\\n          relationTo: 'users',\\n        },\\n      ],\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By generating types, we'll end up with a file containing the following two TypeScript interfaces:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export interface User {\\n  id: string\\n  name: string\\n  email?: string\\n  resetPasswordToken?: string\\n  resetPasswordExpiration?: string\\n  loginAttempts?: number\\n  lockUntil?: string\\n}\\n\\nexport interface Post {\\n  id: string\\n  title?: string\\n  author?: string | User\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Custom Field Interfaces\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For \", _jsx(_components.code, {\n        children: \"array\"\n      }), \", \", _jsx(_components.code, {\n        children: \"block\"\n      }), \", \", _jsx(_components.code, {\n        children: \"group\"\n      }), \" and named \", _jsx(_components.code, {\n        children: \"tab\"\n      }), \" fields, you can generate top level reusable interfaces. The following group field config:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"{\\n  type: 'group',\\n  name: 'meta',\\n  interfaceName: 'SharedMeta', \u003c-- here!!\\n  fields: [\\n    {\\n      name: 'title',\\n      type: 'text',\\n    },\\n    {\\n      name: 'description',\\n      type: 'text',\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"will generate:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// a top level reusable interface!!\\nexport interface SharedMeta {\\n  title?: string\\n  description?: string\\n}\\n\\n// example usage inside collection interface\\nexport interface Collection1 {\\n  // ...other fields\\n  meta?: SharedMeta\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"warning\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Naming Collisions\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Since these types are hoisted to the top level, you need to be aware that naming collisions can\\noccur. For example, if you have a collection with the name of \", _jsx(_components.code, {\n          children: \"Meta\"\n        }), \" and you also create a\\ninterface with the name \", _jsx(_components.code, {\n          children: \"Meta\"\n        }), \" they will collide. It is recommended to scope your interfaces by\\nappending the field type to the end, i.e. \", _jsx(_components.code, {\n          children: \"MetaGroup\"\n        }), \" or similar.\"]\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using your types\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that your types have been generated, Payload's Local API will now be typed. It is common for users to want to use this in their frontend code, we recommend generating them with Payload and then copying the file over to your frontend codebase. This is the simplest way to get your types into your frontend codebase.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Adding an npm script\"\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"warning\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Important\"\n        })\n      }), _jsx(_components.p, {\n        children: \"Payload needs to be able to find your config to generate your types.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload will automatically try and locate your config, but might not always be able to find it. For example, if you are working in a \", _jsx(_components.code, {\n        children: \"/src\"\n      }), \" directory or similar, you need to tell Payload where to find your config manually by using an environment variable. If this applies to you, you can create an npm script to make generating your types easier.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To add an npm script to generate your types and show Payload where to find your config, open your \", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \" and update the \", _jsx(_components.code, {\n        children: \"scripts\"\n      }), \" property to the following:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"{\\n  \\\"scripts\\\": {\\n    \\\"generate:types\\\": \\\"PAYLOAD_CONFIG_PATH=src/payload.config.ts payload generate:types\\\",\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now you can run \", _jsx(_components.code, {\n        children: \"pnpm generate:types\"\n      }), \" to easily generate your types.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["typescript","generating-types"]},"buildId":"pbayt_BRhSN28J-gcoKlf","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>