<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Vercel Content Link</h1><p class="text-xl text-gray-600 mb-8">Payload + Vercel Content Link allows yours editors to navigate directly from the content rendered on your front-end to the fields in Payload that control it.</p><div class="prose prose-lg max-w-none"><p><a href="https://vercel.com/docs/workflow-collaboration/edit-mode#content-link">Vercel Content Link</a> will allow your editors to navigate directly from the content rendered on your front-end to the fields in Payload that control it. This requires no changes to your front-end code and very few changes to your Payload Config.</p>
<p><img src="/images/docs/vercel-visual-editing.jpg" alt="Versions"/></p>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p>Vercel Content Link is an enterprise-only feature and only available for
deployments hosted on Vercel. If you are an existing enterprise customer,
<a href="https://payloadcms.com/for-enterprise">contact our sales team</a> for help with
your integration.</p></div>
<h2>How it works</h2>
<p>To power Vercel Content Link, Payload embeds Content Source Maps into its API responses. Content Source Maps are invisible, encoded JSON values that include a link back to the field in the CMS that generated the content. When rendered on the page, Vercel detects and decodes these values to display the Content Link interface.</p>
<p>For full details on how the encoding and decoding algorithm works, check out <a href="https://www.npmjs.com/package/@vercel/stega"><code>@vercel/stega</code></a>.</p>
<h2>Getting Started</h2>
<p>Setting up Payload with Vercel Content Link is easy. First, install the <code>@payloadcms/plugin-csm</code> plugin into your project. This plugin requires an API key to install, <a href="https://payloadcms.com/for-enterprise">contact our sales team</a> if you don&#x27;t already have one.</p>
<pre><code class="language-bash">npm i @payloadcms/plugin-csm
</code></pre>
<p>Then in the <code>plugins</code> array of your Payload Config, call the plugin and enable any collections that require Content Source Maps.</p>
<pre><code class="language-ts">import { buildConfig } from &quot;payload/config&quot;
import contentSourceMaps from &quot;@payloadcms/plugin-csm&quot;

const config = buildConfig({
  collections: [
    {
      slug: &quot;pages&quot;,
      fields: [
        {
          name: &#x27;slug&#x27;,
          type: &#x27;text&#x27;,
        },
        {
          name: &#x27;title,&#x27;
          type: &#x27;text&#x27;,
        },
      ],
    },
  ],
  plugins: [
    contentSourceMaps({
      collections: [&quot;pages&quot;],
    }),
  ],
})

export default config
</code></pre>
<p>Now in your Next.js app, include the <code>?encodeSourceMaps=true</code> parameter in any of your API requests. For performance reasons, this should only be done when in draft mode or on preview deployments.</p>
<pre><code class="language-ts">if (isDraftMode || process.env.VERCEL_ENV === &#x27;preview&#x27;) {
  const res = await fetch(
    `${process.env.NEXT_PUBLIC_PAYLOAD_CMS_URL}/api/pages?where[slug][equals]=${slug}&amp;encodeSourceMaps=true`,
  )
}
</code></pre>
<p>And that&#x27;s it! You are now ready to enter Edit Mode and begin visually editing your content.</p>
<h4>Edit Mode</h4>
<p>To see Content Link on your site, you first need to visit any preview deployment on Vercel and login using the Vercel Toolbar. When Content Source Maps are detected on the page, a pencil icon will appear in the toolbar. Clicking this icon will enable Edit Mode, highlighting all editable fields on the page in blue.</p>
<p><img src="/images/docs/vercel-toolbar.jpg" alt="Versions"/></p>
<h2>Troubleshooting</h2>
<h3>Date Fields</h3>
<p>The plugin does not encode <code>date</code> fields by default, but for some cases like text that uses negative CSS letter-spacing, it may be necessary to split the encoded data out from the rendered text. This way you can safely use the cleaned data as expected.</p>
<pre><code class="language-ts">import { vercelStegaSplit } from &#x27;@vercel/stega&#x27;
const { cleaned, encoded } = vercelStegaSplit(text)
</code></pre>
<h3>Blocks and array fields</h3>
<p>All <code>blocks</code> and <code>array</code> fields by definition do not have plain text strings to encode. For this reason, they are given an additional <code>_encodedSourceMap</code> property, which you can use to enable Content Link on entire <em>sections</em> of your site. You can then specify the editing container by adding the <code>data-vercel-edit-target</code> HTML attribute to any top-level element of your block.</p>
<pre><code class="language-ts">&lt;div data-vercel-edit-target&gt;
  &lt;span style={{ display: &quot;none&quot; }}&gt;{_encodedSourceMap}&lt;/span&gt;
  {children}
&lt;/div&gt;
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Vercel Content Link","label":"Vercel Content Link","order":10,"desc":"Payload + Vercel Content Link allows yours editors to navigate directly from the content rendered on your front-end to the fields in Payload that control it.","keywords":"vercel, vercel content link, content link, visual editing, content source maps, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    img: \"img\",\n    h2: \"h2\",\n    code: \"code\",\n    pre: \"pre\",\n    h4: \"h4\",\n    h3: \"h3\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://vercel.com/docs/workflow-collaboration/edit-mode#content-link\",\n        children: \"Vercel Content Link\"\n      }), \" will allow your editors to navigate directly from the content rendered on your front-end to the fields in Payload that control it. This requires no changes to your front-end code and very few changes to your Payload Config.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/docs/vercel-visual-editing.jpg\",\n        alt: \"Versions\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"Vercel Content Link is an enterprise-only feature and only available for\\ndeployments hosted on Vercel. If you are an existing enterprise customer,\\n\", _jsx(_components.a, {\n          href: \"https://payloadcms.com/for-enterprise\",\n          children: \"contact our sales team\"\n        }), \" for help with\\nyour integration.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How it works\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To power Vercel Content Link, Payload embeds Content Source Maps into its API responses. Content Source Maps are invisible, encoded JSON values that include a link back to the field in the CMS that generated the content. When rendered on the page, Vercel detects and decodes these values to display the Content Link interface.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For full details on how the encoding and decoding algorithm works, check out \", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/@vercel/stega\",\n        children: _jsx(_components.code, {\n          children: \"@vercel/stega\"\n        })\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Getting Started\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Setting up Payload with Vercel Content Link is easy. First, install the \", _jsx(_components.code, {\n        children: \"@payloadcms/plugin-csm\"\n      }), \" plugin into your project. This plugin requires an API key to install, \", _jsx(_components.a, {\n        href: \"https://payloadcms.com/for-enterprise\",\n        children: \"contact our sales team\"\n      }), \" if you don't already have one.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm i @payloadcms/plugin-csm\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then in the \", _jsx(_components.code, {\n        children: \"plugins\"\n      }), \" array of your Payload Config, call the plugin and enable any collections that require Content Source Maps.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { buildConfig } from \\\"payload/config\\\"\\nimport contentSourceMaps from \\\"@payloadcms/plugin-csm\\\"\\n\\nconst config = buildConfig({\\n  collections: [\\n    {\\n      slug: \\\"pages\\\",\\n      fields: [\\n        {\\n          name: 'slug',\\n          type: 'text',\\n        },\\n        {\\n          name: 'title,'\\n          type: 'text',\\n        },\\n      ],\\n    },\\n  ],\\n  plugins: [\\n    contentSourceMaps({\\n      collections: [\\\"pages\\\"],\\n    }),\\n  ],\\n})\\n\\nexport default config\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now in your Next.js app, include the \", _jsx(_components.code, {\n        children: \"?encodeSourceMaps=true\"\n      }), \" parameter in any of your API requests. For performance reasons, this should only be done when in draft mode or on preview deployments.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"if (isDraftMode || process.env.VERCEL_ENV === 'preview') {\\n  const res = await fetch(\\n    `${process.env.NEXT_PUBLIC_PAYLOAD_CMS_URL}/api/pages?where[slug][equals]=${slug}\u0026encodeSourceMaps=true`,\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And that's it! You are now ready to enter Edit Mode and begin visually editing your content.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Edit Mode\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To see Content Link on your site, you first need to visit any preview deployment on Vercel and login using the Vercel Toolbar. When Content Source Maps are detected on the page, a pencil icon will appear in the toolbar. Clicking this icon will enable Edit Mode, highlighting all editable fields on the page in blue.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/docs/vercel-toolbar.jpg\",\n        alt: \"Versions\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Troubleshooting\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Date Fields\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The plugin does not encode \", _jsx(_components.code, {\n        children: \"date\"\n      }), \" fields by default, but for some cases like text that uses negative CSS letter-spacing, it may be necessary to split the encoded data out from the rendered text. This way you can safely use the cleaned data as expected.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { vercelStegaSplit } from '@vercel/stega'\\nconst { cleaned, encoded } = vercelStegaSplit(text)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Blocks and array fields\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All \", _jsx(_components.code, {\n        children: \"blocks\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"array\"\n      }), \" fields by definition do not have plain text strings to encode. For this reason, they are given an additional \", _jsx(_components.code, {\n        children: \"_encodedSourceMap\"\n      }), \" property, which you can use to enable Content Link on entire \", _jsx(_components.em, {\n        children: \"sections\"\n      }), \" of your site. You can then specify the editing container by adding the \", _jsx(_components.code, {\n        children: \"data-vercel-edit-target\"\n      }), \" HTML attribute to any top-level element of your block.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"\u003cdiv data-vercel-edit-target\u003e\\n  \u003cspan style={{ display: \\\"none\\\" }}\u003e{_encodedSourceMap}\u003c/span\u003e\\n  {children}\\n\u003c/div\u003e\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["integrations","vercel-content-link"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>