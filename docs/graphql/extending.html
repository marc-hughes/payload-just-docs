<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Adding your own Queries and Mutations</h1><p class="text-xl text-gray-600 mb-8">Payload allows you to add your own GraphQL queries and mutations, simply set up GraphQL in your main Payload Config by following these instructions.</p><div class="prose prose-lg max-w-none"><p>You can add your own GraphQL queries and mutations to Payload, making use of all the types that Payload has defined for you.</p>
<p>To do so, add your queries and mutations to the main Payload Config as follows:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Config Path</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>graphQL.queries</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Function that returns an object containing keys to custom GraphQL queries</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>graphQL.mutations</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Function that returns an object containing keys to custom GraphQL mutations</td></tr></tbody></table></div>
<p>The above properties each receive a function that is defined with the following arguments:</p>
<p><strong><code>GraphQL</code></strong></p>
<p>This is Payload&#x27;s GraphQL dependency. You should not install your own copy of GraphQL as a dependency due to underlying restrictions based on how GraphQL works. Instead, you can use the Payload-provided copy via this argument.</p>
<p><strong><code>payload</code></strong></p>
<p>This is a copy of the currently running Payload instance, which provides you with existing GraphQL types for all of your Collections and Globals - among other things.</p>
<h2>Return value</h2>
<p>Both <code>graphQL.queries</code> and <code>graphQL.mutations</code> functions should return an object with properties equal to your newly written GraphQL queries and mutations.</p>
<h2>Example</h2>
<p><code>payload.config.js</code>:</p>
<pre><code class="language-ts">import { buildConfig } from &#x27;payload&#x27;
import myCustomQueryResolver from &#x27;./graphQL/resolvers/myCustomQueryResolver&#x27;

export default buildConfig({
  graphQL: {
    // highlight-start
    queries: (GraphQL, payload) =&gt; {
      return {
        MyCustomQuery: {
          type: new GraphQL.GraphQLObjectType({
            name: &#x27;MyCustomQuery&#x27;,
            fields: {
              text: {
                type: GraphQL.GraphQLString,
              },
              someNumberField: {
                type: GraphQL.GraphQLFloat,
              },
            },
          }),
          args: {
            argNameHere: {
              type: new GraphQL.GraphQLNonNull(GraphQLString),
            },
          },
          resolve: myCustomQueryResolver,
        },
      }
    },
    // highlight-end
  },
})
</code></pre>
<h2>Resolver function</h2>
<p>In your resolver, make sure you set <code>depth: 0</code> if you&#x27;re returning data directly from the Local API so that GraphQL can correctly resolve queries to nested values such as relationship data.</p>
<p>Your function will receive four arguments you can make use of:</p>
<p>Example</p>
<pre><code class="language-ts">;async (obj, args, context, info) =&gt; {}
</code></pre>
<p><strong><code>obj</code></strong></p>
<p>The previous object. Not very often used and usually discarded.</p>
<p><strong><code>args</code></strong></p>
<p>The available arguments from your query or mutation will be available to you here, these must be configured via the custom operation first.</p>
<p><strong><code>context</code></strong></p>
<p>An object containing the <code>req</code> and <code>res</code> objects that will provide you with the <code>payload</code>, <code>user</code> instances and more, like any other Payload API handler.</p>
<p><strong><code>info</code></strong></p>
<p>Contextual information about the currently running GraphQL operation. You can get schema information from this as well as contextual information about where this resolver function is being run.</p>
<h2>Types</h2>
<p>We&#x27;ve exposed a few types and utilities to help you extend the API further. Payload uses the GraphQL.js package for which you can view the full list of available types in the <a href="https://graphql.org/graphql-js/type/">official documentation</a>.</p>
<p><strong><code>GraphQLJSON</code></strong> &amp; <strong><code>GraphQLJSONObject</code></strong></p>
<pre><code class="language-ts">import { GraphQLJSON, GraphQLJSONObject } from &#x27;@payloadcms/graphql/types&#x27;
</code></pre>
<p><strong><code>GraphQL</code></strong></p>
<p>You can directly import the GraphQL package used by Payload, most useful for typing.</p>
<pre><code class="language-ts">import { GraphQL } from &#x27;@payloadcms/graphql/types&#x27;
</code></pre>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p>For queries, mutations and handlers make sure you use the <code>GraphQL</code> and
<code>payload</code> instances provided via arguments.</p></div>
<p><strong><code>buildPaginatedListType</code></strong></p>
<p>This is a utility function that allows you to build a new GraphQL type for a paginated result similar to the Payload&#x27;s generated schema.
It takes in two arguments, the first for the name of this new schema type and the second for the GraphQL type to be used in the docs parameter.</p>
<p>Example</p>
<pre><code class="language-ts">import { buildPaginatedListType } from &#x27;@payloadcms/graphql/types&#x27;

export const getMyPosts = (GraphQL, payload) =&gt; {
  return {
    args: {},
    resolve: Resolver,
    // The name of your new type has to be unique
    type: buildPaginatedListType(
      &#x27;AuthorPosts&#x27;,
      payload.collections[&#x27;posts&#x27;].graphQL?.type,
    ),
  }
}
</code></pre>
<p><strong><code>payload.collections.slug.graphQL</code></strong></p>
<p>If you want to extend more of the provided API then the <code>graphQL</code> object on your collection slug will contain additional types to help you re-use code for types, mutations and queries.</p>
<pre><code class="language-ts">graphQL?: {
  type: GraphQLObjectType
  paginatedType: GraphQLObjectType
  JWT: GraphQLObjectType
  versionType: GraphQLObjectType
  whereInputType: GraphQLInputObjectType
  mutationInputType: GraphQLNonNull&lt;any&gt;
  updateMutationInputType: GraphQLNonNull&lt;any&gt;
}
</code></pre>
<h2>Best practices</h2>
<p>There are a few ways to structure your code, we recommend using a dedicated <code>graphql</code> directory so you can keep all of your logic in one place. You have total freedom of how you want to structure this but a common pattern is to group functions by type and with their resolver.</p>
<p>Example</p>
<pre><code>src/graphql
---- queries/
     index.ts
    -- myCustomQuery/
       index.ts
       resolver.ts

---- mutations/
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Adding your own Queries and Mutations","label":"Custom Queries and Mutations","order":20,"desc":"Payload allows you to add your own GraphQL queries and mutations, simply set up GraphQL in your main Payload Config by following these instructions.","keywords":"graphql, resolvers, mutations, custom, queries, config, configuration, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    code: \"code\",\n    strong: \"strong\",\n    h2: \"h2\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"You can add your own GraphQL queries and mutations to Payload, making use of all the types that Payload has defined for you.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To do so, add your queries and mutations to the main Payload Config as follows:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Config Path\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"graphQL.queries\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Function that returns an object containing keys to custom GraphQL queries\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"graphQL.mutations\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Function that returns an object containing keys to custom GraphQL mutations\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The above properties each receive a function that is defined with the following arguments:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"GraphQL\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is Payload's GraphQL dependency. You should not install your own copy of GraphQL as a dependency due to underlying restrictions based on how GraphQL works. Instead, you can use the Payload-provided copy via this argument.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"payload\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is a copy of the currently running Payload instance, which provides you with existing GraphQL types for all of your Collections and Globals - among other things.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Return value\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Both \", _jsx(_components.code, {\n        children: \"graphQL.queries\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"graphQL.mutations\"\n      }), \" functions should return an object with properties equal to your newly written GraphQL queries and mutations.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"payload.config.js\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { buildConfig } from 'payload'\\nimport myCustomQueryResolver from './graphQL/resolvers/myCustomQueryResolver'\\n\\nexport default buildConfig({\\n  graphQL: {\\n    // highlight-start\\n    queries: (GraphQL, payload) =\u003e {\\n      return {\\n        MyCustomQuery: {\\n          type: new GraphQL.GraphQLObjectType({\\n            name: 'MyCustomQuery',\\n            fields: {\\n              text: {\\n                type: GraphQL.GraphQLString,\\n              },\\n              someNumberField: {\\n                type: GraphQL.GraphQLFloat,\\n              },\\n            },\\n          }),\\n          args: {\\n            argNameHere: {\\n              type: new GraphQL.GraphQLNonNull(GraphQLString),\\n            },\\n          },\\n          resolve: myCustomQueryResolver,\\n        },\\n      }\\n    },\\n    // highlight-end\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Resolver function\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In your resolver, make sure you set \", _jsx(_components.code, {\n        children: \"depth: 0\"\n      }), \" if you're returning data directly from the Local API so that GraphQL can correctly resolve queries to nested values such as relationship data.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Your function will receive four arguments you can make use of:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \";async (obj, args, context, info) =\u003e {}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"obj\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The previous object. Not very often used and usually discarded.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"args\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The available arguments from your query or mutation will be available to you here, these must be configured via the custom operation first.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"context\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An object containing the \", _jsx(_components.code, {\n        children: \"req\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"res\"\n      }), \" objects that will provide you with the \", _jsx(_components.code, {\n        children: \"payload\"\n      }), \", \", _jsx(_components.code, {\n        children: \"user\"\n      }), \" instances and more, like any other Payload API handler.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"info\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Contextual information about the currently running GraphQL operation. You can get schema information from this as well as contextual information about where this resolver function is being run.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Types\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We've exposed a few types and utilities to help you extend the API further. Payload uses the GraphQL.js package for which you can view the full list of available types in the \", _jsx(_components.a, {\n        href: \"https://graphql.org/graphql-js/type/\",\n        children: \"official documentation\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"GraphQLJSON\"\n        })\n      }), \" \u0026 \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"GraphQLJSONObject\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { GraphQLJSON, GraphQLJSONObject } from '@payloadcms/graphql/types'\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"GraphQL\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can directly import the GraphQL package used by Payload, most useful for typing.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { GraphQL } from '@payloadcms/graphql/types'\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"For queries, mutations and handlers make sure you use the \", _jsx(_components.code, {\n          children: \"GraphQL\"\n        }), \" and\\n\", _jsx(_components.code, {\n          children: \"payload\"\n        }), \" instances provided via arguments.\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"buildPaginatedListType\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is a utility function that allows you to build a new GraphQL type for a paginated result similar to the Payload's generated schema.\\nIt takes in two arguments, the first for the name of this new schema type and the second for the GraphQL type to be used in the docs parameter.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { buildPaginatedListType } from '@payloadcms/graphql/types'\\n\\nexport const getMyPosts = (GraphQL, payload) =\u003e {\\n  return {\\n    args: {},\\n    resolve: Resolver,\\n    // The name of your new type has to be unique\\n    type: buildPaginatedListType(\\n      'AuthorPosts',\\n      payload.collections['posts'].graphQL?.type,\\n    ),\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"payload.collections.slug.graphQL\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you want to extend more of the provided API then the \", _jsx(_components.code, {\n        children: \"graphQL\"\n      }), \" object on your collection slug will contain additional types to help you re-use code for types, mutations and queries.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"graphQL?: {\\n  type: GraphQLObjectType\\n  paginatedType: GraphQLObjectType\\n  JWT: GraphQLObjectType\\n  versionType: GraphQLObjectType\\n  whereInputType: GraphQLInputObjectType\\n  mutationInputType: GraphQLNonNull\u003cany\u003e\\n  updateMutationInputType: GraphQLNonNull\u003cany\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Best practices\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are a few ways to structure your code, we recommend using a dedicated \", _jsx(_components.code, {\n        children: \"graphql\"\n      }), \" directory so you can keep all of your logic in one place. You have total freedom of how you want to structure this but a common pattern is to group functions by type and with their resolver.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"src/graphql\\n---- queries/\\n     index.ts\\n    -- myCustomQuery/\\n       index.ts\\n       resolver.ts\\n\\n---- mutations/\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["graphql","extending"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>