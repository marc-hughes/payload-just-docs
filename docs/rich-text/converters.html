<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Converters - Lexical Converters | Payload CMS Documentation</title><meta name="description" content="Conversion between lexical, markdown, jsx and html"/><meta property="og:title" content="Converters - Lexical Converters | Payload CMS Documentation"/><meta property="og:description" content="Conversion between lexical, markdown, jsx and html"/><meta name="next-head-count" content="6"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-8726031e66a50318.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/_tTBTu5tMI_qrBgEpmt0H/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/_tTBTu5tMI_qrBgEpmt0H/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Lexical Converters</h1><p class="text-xl text-gray-600 mb-8">Conversion between lexical, markdown, jsx and html</p><div class="prose prose-lg max-w-none"><p>Richtext fields save data in JSON - this is great for storage and flexibility and allows you to easily to convert it to other formats:</p>
<ul>
<li><a href="/payload-just-docs/docs/rich-text/converting-jsx">Converting JSX</a></li>
<li><a href="/payload-just-docs/docs/rich-text/converting-html">Converting HTML</a></li>
<li><a href="/payload-just-docs/docs/rich-text/converting-plaintext">Converting Plaintext</a></li>
<li><a href="/payload-just-docs/docs/rich-text/converting-markdown">Converting Markdown and MDX</a></li>
</ul>
<h2>Retrieving the Editor Config</h2>
<p>Some converters require access to the Lexical editor config, which defines available features and behaviors. Payload provides multiple ways to obtain the editor config through the <code>editorConfigFactory</code> from <code>@payloadcms/richtext-lexical</code>.</p>
<h3>Importing the Factory</h3>
<p>First, import the necessary utilities:</p>
<pre><code class="language-ts">import type { SanitizedConfig } from &#x27;payload&#x27;
import { editorConfigFactory } from &#x27;@payloadcms/richtext-lexical&#x27;

// Your Payload Config needs to be available in order to retrieve the default editor config
const config: SanitizedConfig = {} as SanitizedConfig
</code></pre>
<h3>Option 1: Default Editor Config</h3>
<p>If you require the default editor config:</p>
<pre><code class="language-ts">const defaultEditorConfig = await editorConfigFactory.default({ config })
</code></pre>
<h3>Option 2: Extract from a Lexical Field</h3>
<p>When a lexical field config is available, you can extract the editor config directly:</p>
<pre><code class="language-ts">const fieldEditorConfig = editorConfigFactory.fromField({
  field: config.collections[0].fields[1],
})
</code></pre>
<h3>Option 3: Create a Custom Editor Config</h3>
<p>You can create a custom editor configuration by specifying additional features:</p>
<pre><code class="language-ts">import { FixedToolbarFeature } from &#x27;@payloadcms/richtext-lexical&#x27;

const customEditorConfig = await editorConfigFactory.fromFeatures({
  config,
  features: ({ defaultFeatures }) =&gt; [
    ...defaultFeatures,
    FixedToolbarFeature(),
  ],
})
</code></pre>
<h3>Option 4: Extract from an Instantiated Editor</h3>
<p>If you&#x27;ve created a global or reusable Lexical editor instance, you can access its configuration. This method is typically less efficient and not recommended:</p>
<pre><code class="language-ts">const editor = lexicalEditor({
  features: ({ defaultFeatures }) =&gt; [
    ...defaultFeatures,
    FixedToolbarFeature(),
  ],
})

const instantiatedEditorConfig = await editorConfigFactory.fromEditor({
  config,
  editor,
})
</code></pre>
<p>For better efficiency, consider extracting the <code>features</code> into a separate variable and using <code>fromFeatures</code> instead of this method.</p>
<h3>Example - Retrieving the editor config from an existing field</h3>
<p>If you have access to the sanitized collection config, you can access the lexical sanitized editor config, as every lexical richText field returns it. Here is an example how you can retrieve it from another field&#x27;s afterRead hook:</p>
<pre><code class="language-ts">import type { CollectionConfig, RichTextField } from &#x27;payload&#x27;

import {
  editorConfigFactory,
  getEnabledNodes,
  lexicalEditor,
} from &#x27;@payloadcms/richtext-lexical&#x27;

export const MyCollection: CollectionConfig = {
  slug: &#x27;slug&#x27;,
  fields: [
    {
      name: &#x27;text&#x27;,
      type: &#x27;text&#x27;,
      hooks: {
        afterRead: [
          ({ siblingFields, value }) =&gt; {
            const field: RichTextField = siblingFields.find(
              (field) =&gt; &#x27;name&#x27; in field &amp;&amp; field.name === &#x27;richText&#x27;,
            ) as RichTextField

            const editorConfig = editorConfigFactory.fromField({
              field,
            })

            // Now you can use the editor config

            return value
          },
        ],
      },
    },
    {
      name: &#x27;richText&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor(),
    },
  ],
}
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Lexical Converters","label":"Converters","order":20,"desc":"Conversion between lexical, markdown, jsx and html","keywords":"lexical, rich text, editor, headless cms, convert, html, mdx, markdown, md, conversion, export, jsx"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    h2: \"h2\",\n    code: \"code\",\n    h3: \"h3\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Richtext fields save data in JSON - this is great for storage and flexibility and allows you to easily to convert it to other formats:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-jsx\",\n          children: \"Converting JSX\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-html\",\n          children: \"Converting HTML\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-plaintext\",\n          children: \"Converting Plaintext\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-markdown\",\n          children: \"Converting Markdown and MDX\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Retrieving the Editor Config\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Some converters require access to the Lexical editor config, which defines available features and behaviors. Payload provides multiple ways to obtain the editor config through the \", _jsx(_components.code, {\n        children: \"editorConfigFactory\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Importing the Factory\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, import the necessary utilities:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SanitizedConfig } from 'payload'\\nimport { editorConfigFactory } from '@payloadcms/richtext-lexical'\\n\\n// Your Payload Config needs to be available in order to retrieve the default editor config\\nconst config: SanitizedConfig = {} as SanitizedConfig\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 1: Default Editor Config\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you require the default editor config:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const defaultEditorConfig = await editorConfigFactory.default({ config })\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 2: Extract from a Lexical Field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When a lexical field config is available, you can extract the editor config directly:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const fieldEditorConfig = editorConfigFactory.fromField({\\n  field: config.collections[0].fields[1],\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 3: Create a Custom Editor Config\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can create a custom editor configuration by specifying additional features:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { FixedToolbarFeature } from '@payloadcms/richtext-lexical'\\n\\nconst customEditorConfig = await editorConfigFactory.fromFeatures({\\n  config,\\n  features: ({ defaultFeatures }) =\u003e [\\n    ...defaultFeatures,\\n    FixedToolbarFeature(),\\n  ],\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 4: Extract from an Instantiated Editor\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you've created a global or reusable Lexical editor instance, you can access its configuration. This method is typically less efficient and not recommended:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const editor = lexicalEditor({\\n  features: ({ defaultFeatures }) =\u003e [\\n    ...defaultFeatures,\\n    FixedToolbarFeature(),\\n  ],\\n})\\n\\nconst instantiatedEditorConfig = await editorConfigFactory.fromEditor({\\n  config,\\n  editor,\\n})\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For better efficiency, consider extracting the \", _jsx(_components.code, {\n        children: \"features\"\n      }), \" into a separate variable and using \", _jsx(_components.code, {\n        children: \"fromFeatures\"\n      }), \" instead of this method.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example - Retrieving the editor config from an existing field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you have access to the sanitized collection config, you can access the lexical sanitized editor config, as every lexical richText field returns it. Here is an example how you can retrieve it from another field's afterRead hook:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig, RichTextField } from 'payload'\\n\\nimport {\\n  editorConfigFactory,\\n  getEnabledNodes,\\n  lexicalEditor,\\n} from '@payloadcms/richtext-lexical'\\n\\nexport const MyCollection: CollectionConfig = {\\n  slug: 'slug',\\n  fields: [\\n    {\\n      name: 'text',\\n      type: 'text',\\n      hooks: {\\n        afterRead: [\\n          ({ siblingFields, value }) =\u003e {\\n            const field: RichTextField = siblingFields.find(\\n              (field) =\u003e 'name' in field \u0026\u0026 field.name === 'richText',\\n            ) as RichTextField\\n\\n            const editorConfig = editorConfigFactory.fromField({\\n              field,\\n            })\\n\\n            // Now you can use the editor config\\n\\n            return value\\n          },\\n        ],\\n      },\\n    },\\n    {\\n      name: 'richText',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n  ],\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["rich-text","converters"]},"buildId":"_tTBTu5tMI_qrBgEpmt0H","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>