<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Converting HTML</h1><p class="text-xl text-gray-600 mb-8">Converting between lexical richtext and HTML</p><div class="prose prose-lg max-w-none"><h2>Converting Rich Text to HTML</h2>
<p>There are two main approaches to convert your Lexical-based rich text to HTML:</p>
<ol>
<li><strong>Generate HTML on-demand (Recommended)</strong>: Convert JSON to HTML wherever you need it, on-demand.</li>
<li><strong>Generate HTML within your Collection</strong>: Create a new field that automatically converts your saved JSON content to HTML. This is not recommended because it adds overhead to the Payload API and may not work well with live preview.</li>
</ol>
<h3>Generating HTML on-demand (Recommended)</h3>
<p>To convert JSON to HTML on-demand, use the <code>convertLexicalToHTML</code> function from <code>@payloadcms/richtext-lexical/html</code>. Here&#x27;s an example of how to use it in a React component in your frontend:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;

import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;
import { convertLexicalToHTML } from &#x27;@payloadcms/richtext-lexical/html&#x27;

import React from &#x27;react&#x27;

export const MyComponent = ({ data }: { data: SerializedEditorState }) =&gt; {
  const html = convertLexicalToHTML({ data })

  return &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;
}
</code></pre>
<h3>Converting Lexical Blocks</h3>
<p>If your rich text includes Lexical blocks, you need to provide a way to convert them to HTML. For example:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;

import type { MyInlineBlock, MyTextBlock } from &#x27;@/payload-types&#x27;
import type {
  DefaultNodeTypes,
  SerializedBlockNode,
  SerializedInlineBlockNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import {
  convertLexicalToHTML,
  type HTMLConvertersFunction,
} from &#x27;@payloadcms/richtext-lexical/html&#x27;
import React from &#x27;react&#x27;

type NodeTypes =
  | DefaultNodeTypes
  | SerializedBlockNode&lt;MyTextBlock&gt;
  | SerializedInlineBlockNode&lt;MyInlineBlock&gt;

const htmlConverters: HTMLConvertersFunction&lt;NodeTypes&gt; = ({
  defaultConverters,
}) =&gt; ({
  ...defaultConverters,
  blocks: {
    // Each key should match your block&#x27;s slug
    myTextBlock: ({ node, providedCSSString }) =&gt;
      `&lt;div style=&quot;background-color: red;${providedCSSString}&quot;&gt;${node.fields.text}&lt;/div&gt;`,
  },
  inlineBlocks: {
    // Each key should match your inline block&#x27;s slug
    myInlineBlock: ({ node, providedStyleTag }) =&gt;
      `&lt;span${providedStyleTag}&gt;${node.fields.text}&lt;/span$&gt;`,
  },
})

export const MyComponent = ({ data }: { data: SerializedEditorState }) =&gt; {
  const html = convertLexicalToHTML({
    converters: htmlConverters,
    data,
  })

  return &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;
}
</code></pre>
<h3>Outputting HTML from the Collection</h3>
<p>To automatically generate HTML from the saved richText field in your Collection, use the <code>lexicalHTMLField()</code> helper. This approach converts the JSON to HTML using an <code>afterRead</code> hook. For instance:</p>
<pre><code class="language-ts">import type { HTMLConvertersFunction } from &#x27;@payloadcms/richtext-lexical/html&#x27;
import type { MyTextBlock } from &#x27;@/payload-types.js&#x27;
import type { CollectionConfig } from &#x27;payload&#x27;

import {
  BlocksFeature,
  type DefaultNodeTypes,
  lexicalEditor,
  lexicalHTMLField,
  type SerializedBlockNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;

const Pages: CollectionConfig = {
  slug: &#x27;pages&#x27;,
  fields: [
    {
      name: &#x27;nameOfYourRichTextField&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor(),
    },
    lexicalHTMLField({
      htmlFieldName: &#x27;nameOfYourRichTextField_html&#x27;,
      lexicalFieldName: &#x27;nameOfYourRichTextField&#x27;,
    }),
    {
      name: &#x27;customRichText&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor({
        features: ({ defaultFeatures }) =&gt; [
          ...defaultFeatures,
          BlocksFeature({
            blocks: [
              {
                interfaceName: &#x27;MyTextBlock&#x27;,
                slug: &#x27;myTextBlock&#x27;,
                fields: [
                  {
                    name: &#x27;text&#x27;,
                    type: &#x27;text&#x27;,
                  },
                ],
              },
            ],
          }),
        ],
      }),
    },
    lexicalHTMLField({
      htmlFieldName: &#x27;customRichText_html&#x27;,
      lexicalFieldName: &#x27;customRichText&#x27;,
      // can pass in additional converters or override default ones
      converters: (({ defaultConverters }) =&gt; ({
        ...defaultConverters,
        blocks: {
          myTextBlock: ({ node, providedCSSString }) =&gt;
            `&lt;div style=&quot;background-color: red;${providedCSSString}&quot;&gt;${node.fields.text}&lt;/div&gt;`,
        },
      })) as HTMLConvertersFunction&lt;
        DefaultNodeTypes | SerializedBlockNode&lt;MyTextBlock&gt;
      &gt;,
    }),
  ],
}
</code></pre>
<h3>Generating HTML in Your Frontend with Dynamic Population (Advanced)</h3>
<p>By default, <code>convertLexicalToHTML</code> expects fully populated data (e.g. uploads, links, etc.). If you need to dynamically fetch and populate those nodes, use the async variant, <code>convertLexicalToHTMLAsync</code>, from <code>@payloadcms/richtext-lexical/html-async</code>. You must provide a <code>populate</code> function:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;

import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import { getRestPopulateFn } from &#x27;@payloadcms/richtext-lexical/client&#x27;
import { convertLexicalToHTMLAsync } from &#x27;@payloadcms/richtext-lexical/html-async&#x27;
import React, { useEffect, useState } from &#x27;react&#x27;

export const MyComponent = ({ data }: { data: SerializedEditorState }) =&gt; {
  const [html, setHTML] = useState&lt;null | string&gt;(null)
  useEffect(() =&gt; {
    async function convert() {
      const html = await convertLexicalToHTMLAsync({
        data,
        populate: getRestPopulateFn({
          apiURL: `http://localhost:3000/api`,
        }),
      })
      setHTML(html)
    }

    void convert()
  }, [data])

  return html &amp;&amp; &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;
}
</code></pre>
<p>Using the REST populate function will send a separate request for each node. If you need to populate a large number of nodes, this may be slow. For improved performance on the server, you can use the <code>getPayloadPopulateFn</code> function:</p>
<pre><code class="language-tsx">import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import { getPayloadPopulateFn } from &#x27;@payloadcms/richtext-lexical&#x27;
import { convertLexicalToHTMLAsync } from &#x27;@payloadcms/richtext-lexical/html-async&#x27;
import { getPayload } from &#x27;payload&#x27;
import React from &#x27;react&#x27;

import config from &#x27;../../config.js&#x27;

export const MyRSCComponent = async ({
  data,
}: {
  data: SerializedEditorState
}) =&gt; {
  const payload = await getPayload({
    config,
  })

  const html = await convertLexicalToHTMLAsync({
    data,
    populate: await getPayloadPopulateFn({
      currentDepth: 0,
      depth: 1,
      payload,
    }),
  })

  return html &amp;&amp; &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt;
}
</code></pre>
<h2>Converting HTML to Richtext</h2>
<p>If you need to convert raw HTML into a Lexical editor state, use <code>convertHTMLToLexical</code> from <code>@payloadcms/richtext-lexical</code>, along with the <a href="/docs/rich-text/converters#retrieving-the-editor-config">editorConfigFactory to retrieve the editor config</a>:</p>
<pre><code class="language-ts">import {
  convertHTMLToLexical,
  editorConfigFactory,
} from &#x27;@payloadcms/richtext-lexical&#x27;
// Make sure you have jsdom and @types/jsdom installed
import { JSDOM } from &#x27;jsdom&#x27;

const html = convertHTMLToLexical({
  editorConfig: await editorConfigFactory.default({
    config, // Your Payload Config
  }),
  html: &#x27;&lt;p&gt;text&lt;/p&gt;&#x27;,
  JSDOM, // Pass in the JSDOM import; it&#x27;s not bundled to keep package size small
})
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Converting HTML","label":"Converting HTML","order":22,"desc":"Converting between lexical richtext and HTML","keywords":"lexical, richtext, html"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    h3: \"h3\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Rich Text to HTML\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two main approaches to convert your Lexical-based rich text to HTML:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Generate HTML on-demand (Recommended)\"\n        }), \": Convert JSON to HTML wherever you need it, on-demand.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Generate HTML within your Collection\"\n        }), \": Create a new field that automatically converts your saved JSON content to HTML. This is not recommended because it adds overhead to the Payload API and may not work well with live preview.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Generating HTML on-demand (Recommended)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To convert JSON to HTML on-demand, use the \", _jsx(_components.code, {\n        children: \"convertLexicalToHTML\"\n      }), \" function from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/html\"\n      }), \". Here's an example of how to use it in a React component in your frontend:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'\\n\\nimport React from 'react'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) =\u003e {\\n  const html = convertLexicalToHTML({ data })\\n\\n  return \u003cdiv dangerouslySetInnerHTML={{ __html: html }} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Lexical Blocks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your rich text includes Lexical blocks, you need to provide a way to convert them to HTML. For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { MyInlineBlock, MyTextBlock } from '@/payload-types'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n  SerializedInlineBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  convertLexicalToHTML,\\n  type HTMLConvertersFunction,\\n} from '@payloadcms/richtext-lexical/html'\\nimport React from 'react'\\n\\ntype NodeTypes =\\n  | DefaultNodeTypes\\n  | SerializedBlockNode\u003cMyTextBlock\u003e\\n  | SerializedInlineBlockNode\u003cMyInlineBlock\u003e\\n\\nconst htmlConverters: HTMLConvertersFunction\u003cNodeTypes\u003e = ({\\n  defaultConverters,\\n}) =\u003e ({\\n  ...defaultConverters,\\n  blocks: {\\n    // Each key should match your block's slug\\n    myTextBlock: ({ node, providedCSSString }) =\u003e\\n      `\u003cdiv style=\\\"background-color: red;${providedCSSString}\\\"\u003e${node.fields.text}\u003c/div\u003e`,\\n  },\\n  inlineBlocks: {\\n    // Each key should match your inline block's slug\\n    myInlineBlock: ({ node, providedStyleTag }) =\u003e\\n      `\u003cspan${providedStyleTag}\u003e${node.fields.text}\u003c/span$\u003e`,\\n  },\\n})\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) =\u003e {\\n  const html = convertLexicalToHTML({\\n    converters: htmlConverters,\\n    data,\\n  })\\n\\n  return \u003cdiv dangerouslySetInnerHTML={{ __html: html }} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Outputting HTML from the Collection\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To automatically generate HTML from the saved richText field in your Collection, use the \", _jsx(_components.code, {\n        children: \"lexicalHTMLField()\"\n      }), \" helper. This approach converts the JSON to HTML using an \", _jsx(_components.code, {\n        children: \"afterRead\"\n      }), \" hook. For instance:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { HTMLConvertersFunction } from '@payloadcms/richtext-lexical/html'\\nimport type { MyTextBlock } from '@/payload-types.js'\\nimport type { CollectionConfig } from 'payload'\\n\\nimport {\\n  BlocksFeature,\\n  type DefaultNodeTypes,\\n  lexicalEditor,\\n  lexicalHTMLField,\\n  type SerializedBlockNode,\\n} from '@payloadcms/richtext-lexical'\\n\\nconst Pages: CollectionConfig = {\\n  slug: 'pages',\\n  fields: [\\n    {\\n      name: 'nameOfYourRichTextField',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n    lexicalHTMLField({\\n      htmlFieldName: 'nameOfYourRichTextField_html',\\n      lexicalFieldName: 'nameOfYourRichTextField',\\n    }),\\n    {\\n      name: 'customRichText',\\n      type: 'richText',\\n      editor: lexicalEditor({\\n        features: ({ defaultFeatures }) =\u003e [\\n          ...defaultFeatures,\\n          BlocksFeature({\\n            blocks: [\\n              {\\n                interfaceName: 'MyTextBlock',\\n                slug: 'myTextBlock',\\n                fields: [\\n                  {\\n                    name: 'text',\\n                    type: 'text',\\n                  },\\n                ],\\n              },\\n            ],\\n          }),\\n        ],\\n      }),\\n    },\\n    lexicalHTMLField({\\n      htmlFieldName: 'customRichText_html',\\n      lexicalFieldName: 'customRichText',\\n      // can pass in additional converters or override default ones\\n      converters: (({ defaultConverters }) =\u003e ({\\n        ...defaultConverters,\\n        blocks: {\\n          myTextBlock: ({ node, providedCSSString }) =\u003e\\n            `\u003cdiv style=\\\"background-color: red;${providedCSSString}\\\"\u003e${node.fields.text}\u003c/div\u003e`,\\n        },\\n      })) as HTMLConvertersFunction\u003c\\n        DefaultNodeTypes | SerializedBlockNode\u003cMyTextBlock\u003e\\n      \u003e,\\n    }),\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Generating HTML in Your Frontend with Dynamic Population (Advanced)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default, \", _jsx(_components.code, {\n        children: \"convertLexicalToHTML\"\n      }), \" expects fully populated data (e.g. uploads, links, etc.). If you need to dynamically fetch and populate those nodes, use the async variant, \", _jsx(_components.code, {\n        children: \"convertLexicalToHTMLAsync\"\n      }), \", from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/html-async\"\n      }), \". You must provide a \", _jsx(_components.code, {\n        children: \"populate\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { getRestPopulateFn } from '@payloadcms/richtext-lexical/client'\\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\\nimport React, { useEffect, useState } from 'react'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) =\u003e {\\n  const [html, setHTML] = useState\u003cnull | string\u003e(null)\\n  useEffect(() =\u003e {\\n    async function convert() {\\n      const html = await convertLexicalToHTMLAsync({\\n        data,\\n        populate: getRestPopulateFn({\\n          apiURL: `http://localhost:3000/api`,\\n        }),\\n      })\\n      setHTML(html)\\n    }\\n\\n    void convert()\\n  }, [data])\\n\\n  return html \u0026\u0026 \u003cdiv dangerouslySetInnerHTML={{ __html: html }} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Using the REST populate function will send a separate request for each node. If you need to populate a large number of nodes, this may be slow. For improved performance on the server, you can use the \", _jsx(_components.code, {\n        children: \"getPayloadPopulateFn\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { getPayloadPopulateFn } from '@payloadcms/richtext-lexical'\\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\\nimport { getPayload } from 'payload'\\nimport React from 'react'\\n\\nimport config from '../../config.js'\\n\\nexport const MyRSCComponent = async ({\\n  data,\\n}: {\\n  data: SerializedEditorState\\n}) =\u003e {\\n  const payload = await getPayload({\\n    config,\\n  })\\n\\n  const html = await convertLexicalToHTMLAsync({\\n    data,\\n    populate: await getPayloadPopulateFn({\\n      currentDepth: 0,\\n      depth: 1,\\n      payload,\\n    }),\\n  })\\n\\n  return html \u0026\u0026 \u003cdiv dangerouslySetInnerHTML={{ __html: html }} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Converting HTML to Richtext\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you need to convert raw HTML into a Lexical editor state, use \", _jsx(_components.code, {\n        children: \"convertHTMLToLexical\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical\"\n      }), \", along with the \", _jsx(_components.a, {\n        href: \"/docs/rich-text/converters#retrieving-the-editor-config\",\n        children: \"editorConfigFactory to retrieve the editor config\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import {\\n  convertHTMLToLexical,\\n  editorConfigFactory,\\n} from '@payloadcms/richtext-lexical'\\n// Make sure you have jsdom and @types/jsdom installed\\nimport { JSDOM } from 'jsdom'\\n\\nconst html = convertHTMLToLexical({\\n  editorConfig: await editorConfigFactory.default({\\n    config, // Your Payload Config\\n  }),\\n  html: '\u003cp\u003etext\u003c/p\u003e',\\n  JSDOM, // Pass in the JSDOM import; it's not bundled to keep package size small\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["rich-text","converting-html"]},"buildId":"pbayt_BRhSN28J-gcoKlf","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>