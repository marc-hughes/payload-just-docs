<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Converting Plaintext</h1><p class="text-xl text-gray-600 mb-8">Converting between lexical richtext and plaintext</p><div class="prose prose-lg max-w-none"><h2>Converting Richtext to Plaintext</h2>
<p>Here&#x27;s how you can convert richtext data to plaintext using <code>@payloadcms/richtext-lexical/plaintext</code>.</p>
<pre><code class="language-ts">import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import { convertLexicalToPlaintext } from &#x27;@payloadcms/richtext-lexical/plaintext&#x27;

// Your richtext data here
const data: SerializedEditorState = {}

const plaintext = convertLexicalToPlaintext({ data })
</code></pre>
<h3>Custom Converters</h3>
<p>The <code>convertLexicalToPlaintext</code> functions accepts a <code>converters</code> object that allows you to customize how specific nodes are converted to plaintext.</p>
<pre><code class="language-ts">import type {
  DefaultNodeTypes,
  SerializedBlockNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;
import type { MyTextBlock } from &#x27;@/payload-types&#x27;

import {
  convertLexicalToPlaintext,
  type PlaintextConverters,
} from &#x27;@payloadcms/richtext-lexical/plaintext&#x27;

// Your richtext data here
const data: SerializedEditorState = {}

const converters: PlaintextConverters&lt;
  DefaultNodeTypes | SerializedBlockNode&lt;MyTextBlock&gt;
&gt; = {
  blocks: {
    textBlock: ({ node }) =&gt; {
      return node.fields.text ?? &#x27;&#x27;
    },
  },
  link: ({ node }) =&gt; {
    return node.fields.url ?? &#x27;&#x27;
  },
}

const plaintext = convertLexicalToPlaintext({
  converters,
  data,
})
</code></pre>
<p>Unlike other converters, there are no default converters for plaintext.</p>
<p>If a node does not have a converter defined, the following heuristics are used to convert it to plaintext:</p>
<ul>
<li>If the node has a <code>text</code> field, it will be used as the plaintext.</li>
<li>If the node has a <code>children</code> field, the children will be recursively converted to plaintext.</li>
<li>If the node has neither, it will be ignored.</li>
<li>Paragraph, text and tab nodes insert newline / tab characters.</li>
</ul></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Converting Plaintext","label":"Converting Plaintext","order":24,"desc":"Converting between lexical richtext and plaintext","keywords":"lexical, richtext, plaintext, text"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Richtext to Plaintext\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here's how you can convert richtext data to plaintext using \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/plaintext\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { convertLexicalToPlaintext } from '@payloadcms/richtext-lexical/plaintext'\\n\\n// Your richtext data here\\nconst data: SerializedEditorState = {}\\n\\nconst plaintext = convertLexicalToPlaintext({ data })\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Custom Converters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"convertLexicalToPlaintext\"\n      }), \" functions accepts a \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" object that allows you to customize how specific nodes are converted to plaintext.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport type { MyTextBlock } from '@/payload-types'\\n\\nimport {\\n  convertLexicalToPlaintext,\\n  type PlaintextConverters,\\n} from '@payloadcms/richtext-lexical/plaintext'\\n\\n// Your richtext data here\\nconst data: SerializedEditorState = {}\\n\\nconst converters: PlaintextConverters\u003c\\n  DefaultNodeTypes | SerializedBlockNode\u003cMyTextBlock\u003e\\n\u003e = {\\n  blocks: {\\n    textBlock: ({ node }) =\u003e {\\n      return node.fields.text ?? ''\\n    },\\n  },\\n  link: ({ node }) =\u003e {\\n    return node.fields.url ?? ''\\n  },\\n}\\n\\nconst plaintext = convertLexicalToPlaintext({\\n  converters,\\n  data,\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Unlike other converters, there are no default converters for plaintext.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If a node does not have a converter defined, the following heuristics are used to convert it to plaintext:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"If the node has a \", _jsx(_components.code, {\n          children: \"text\"\n        }), \" field, it will be used as the plaintext.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"If the node has a \", _jsx(_components.code, {\n          children: \"children\"\n        }), \" field, the children will be recursively converted to plaintext.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If the node has neither, it will be ignored.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Paragraph, text and tab nodes insert newline / tab characters.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["rich-text","converting-plaintext"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>