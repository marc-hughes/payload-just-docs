<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Converting Markdown</h1><p class="text-xl text-gray-600 mb-8">Converting between lexical richtext and Markdown / MDX</p><div class="prose prose-lg max-w-none"><h2>Converting Richtext to Markdown</h2>
<p>If you have access to the Payload Config and the <a href="/payload-just-docs/docs/rich-text/converters#retrieving-the-editor-config">lexical editor config</a>, you can convert the lexical editor state to Markdown with the following:</p>
<pre><code class="language-ts">import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import {
  convertLexicalToMarkdown,
  editorConfigFactory,
} from &#x27;@payloadcms/richtext-lexical&#x27;

// Your richtext data here
const data: SerializedEditorState = {}

const markdown = convertLexicalToMarkdown({
  data,
  editorConfig: await editorConfigFactory.default({
    config, // &lt;= make sure you have access to your Payload Config
  }),
})
</code></pre>
<h3>Example - outputting Markdown from the Collection</h3>
<pre><code class="language-ts">import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;
import type { CollectionConfig, RichTextField } from &#x27;payload&#x27;

import {
  convertLexicalToMarkdown,
  editorConfigFactory,
  lexicalEditor,
} from &#x27;@payloadcms/richtext-lexical&#x27;

const Pages: CollectionConfig = {
  slug: &#x27;pages&#x27;,
  fields: [
    {
      name: &#x27;nameOfYourRichTextField&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor(),
    },
    {
      name: &#x27;markdown&#x27;,
      type: &#x27;textarea&#x27;,
      admin: {
        hidden: true,
      },
      hooks: {
        afterRead: [
          ({ siblingData, siblingFields }) =&gt; {
            const data: SerializedEditorState =
              siblingData[&#x27;nameOfYourRichTextField&#x27;]

            if (!data) {
              return &#x27;&#x27;
            }

            const markdown = convertLexicalToMarkdown({
              data,
              editorConfig: editorConfigFactory.fromField({
                field: siblingFields.find(
                  (field) =&gt;
                    &#x27;name&#x27; in field &amp;&amp; field.name === &#x27;nameOfYourRichTextField&#x27;,
                ) as RichTextField,
              }),
            })

            return markdown
          },
        ],
        beforeChange: [
          ({ siblingData }) =&gt; {
            // Ensure that the markdown field is not saved in the database
            delete siblingData[&#x27;markdown&#x27;]
            return null
          },
        ],
      },
    },
  ],
}
</code></pre>
<h2>Converting Markdown to Richtext</h2>
<p>If you have access to the Payload Config and the <a href="/payload-just-docs/docs/rich-text/converters#retrieving-the-editor-config">lexical editor config</a>, you can convert Markdown to the lexical editor state with the following:</p>
<pre><code class="language-ts">import {
  convertMarkdownToLexical,
  editorConfigFactory,
} from &#x27;@payloadcms/richtext-lexical&#x27;

const lexicalJSON = convertMarkdownToLexical({
  editorConfig: await editorConfigFactory.default({
    config, // &lt;= make sure you have access to your Payload Config
  }),
  markdown: &#x27;# Hello world\n\nThis is a **test**.&#x27;,
})
</code></pre>
<h2>Converting MDX</h2>
<p>Payload supports serializing and deserializing MDX content. While Markdown converters are stored on the features, MDX converters are stored on the blocks that you pass to the <code>BlocksFeature</code>.</p>
<h3>Defining a Custom Block</h3>
<p>Here is an example of a <code>Banner</code> block.</p>
<p>This block:</p>
<ul>
<li>Renders in the admin UI as a normal Lexical block with specific fields (e.g. type, content).</li>
<li>Converts to an MDX <code>Banner</code> component.</li>
<li>Can parse that MDX <code>Banner</code> back into a Lexical state.</li>
</ul>
<figure class="my-8"><picture><source srcSet="https://payloadcms.com/images/docs/mdx-example-dark.png" media="(prefers-color-scheme: dark)"/><img src="https://payloadcms.com/images/docs/mdx-example-light.png" alt="Shows the Banner field in a lexical editor and the MDX output" class="w-full rounded-lg shadow-lg"/></picture><figcaption class="mt-3 text-sm text-center text-gray-600 dark:text-gray-400">Banner field in a lexical editor and the MDX output</figcaption></figure>
<pre><code class="language-ts">import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;
import type { Block, CollectionConfig, RichTextField } from &#x27;payload&#x27;

import {
  BlocksFeature,
  convertLexicalToMarkdown,
  editorConfigFactory,
  lexicalEditor,
} from &#x27;@payloadcms/richtext-lexical&#x27;

const BannerBlock: Block = {
  slug: &#x27;Banner&#x27;,
  fields: [
    {
      name: &#x27;type&#x27;,
      type: &#x27;select&#x27;,
      defaultValue: &#x27;info&#x27;,
      options: [
        { label: &#x27;Info&#x27;, value: &#x27;info&#x27; },
        { label: &#x27;Warning&#x27;, value: &#x27;warning&#x27; },
        { label: &#x27;Error&#x27;, value: &#x27;error&#x27; },
      ],
    },
    {
      name: &#x27;content&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor(),
    },
  ],
  jsx: {
    /**
     * Convert from Lexical -&gt; MDX:
     * &lt;Banner type=&quot;...&quot; &gt;child content&lt;/Banner&gt;
     */
    export: ({ fields, lexicalToMarkdown }) =&gt; {
      const props: any = {}
      if (fields.type) {
        props.type = fields.type
      }

      return {
        children: lexicalToMarkdown({ editorState: fields.content }),
        props,
      }
    },
    /**
     * Convert from MDX -&gt; Lexical:
     */
    import: ({ children, markdownToLexical, props }) =&gt; {
      return {
        type: props?.type,
        content: markdownToLexical({ markdown: children }),
      }
    },
  },
}

const Pages: CollectionConfig = {
  slug: &#x27;pages&#x27;,
  fields: [
    {
      name: &#x27;nameOfYourRichTextField&#x27;,
      type: &#x27;richText&#x27;,
      editor: lexicalEditor({
        features: ({ defaultFeatures }) =&gt; [
          ...defaultFeatures,
          BlocksFeature({
            blocks: [BannerBlock],
          }),
        ],
      }),
    },
    {
      name: &#x27;markdown&#x27;,
      type: &#x27;textarea&#x27;,
      hooks: {
        afterRead: [
          ({ siblingData, siblingFields }) =&gt; {
            const data: SerializedEditorState =
              siblingData[&#x27;nameOfYourRichTextField&#x27;]

            if (!data) {
              return &#x27;&#x27;
            }

            const markdown = convertLexicalToMarkdown({
              data,
              editorConfig: editorConfigFactory.fromField({
                field: siblingFields.find(
                  (field) =&gt;
                    &#x27;name&#x27; in field &amp;&amp; field.name === &#x27;nameOfYourRichTextField&#x27;,
                ) as RichTextField,
              }),
            })

            return markdown
          },
        ],
        beforeChange: [
          ({ siblingData }) =&gt; {
            // Ensure that the markdown field is not saved in the database
            delete siblingData[&#x27;markdown&#x27;]
            return null
          },
        ],
      },
    },
  ],
}
</code></pre>
<p>The conversion is done using the <code>jsx</code> property of the block. The <code>export</code> function is called when converting from lexical to MDX, and the <code>import</code> function is called when converting from MDX to lexical.</p>
<h3>Export</h3>
<p>The <code>export</code> function takes the block field data and the <code>lexicalToMarkdown</code> function as arguments. It returns the following object:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Property</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>children</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">string</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">This will be in between the opening and closing tags of the block.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>props</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">object</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">This will be in the opening tag of the block.</td></tr></tbody></table></div>
<h3>Import</h3>
<p>The <code>import</code> function provides data extracted from the MDX. It takes the following arguments:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Argument</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>children</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">string</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">This will be the text between the opening and closing tags of the block.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>props</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">object</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">These are the props passed to the block, parsed from the opening tag into an object.</td></tr></tbody></table></div>
<p>The returning object is equal to the block field data.</p></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Converting Markdown","label":"Converting Markdown","order":23,"desc":"Converting between lexical richtext and Markdown / MDX","keywords":"lexical, richtext, markdown, md, mdx"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components), {LightDarkImage} = _components;\n  if (!LightDarkImage) _missingMdxReference(\"LightDarkImage\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Richtext to Markdown\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you have access to the Payload Config and the \", _jsx(_components.a, {\n        href: \"/docs/rich-text/converters#retrieving-the-editor-config\",\n        children: \"lexical editor config\"\n      }), \", you can convert the lexical editor state to Markdown with the following:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  convertLexicalToMarkdown,\\n  editorConfigFactory,\\n} from '@payloadcms/richtext-lexical'\\n\\n// Your richtext data here\\nconst data: SerializedEditorState = {}\\n\\nconst markdown = convertLexicalToMarkdown({\\n  data,\\n  editorConfig: await editorConfigFactory.default({\\n    config, // \u003c= make sure you have access to your Payload Config\\n  }),\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example - outputting Markdown from the Collection\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport type { CollectionConfig, RichTextField } from 'payload'\\n\\nimport {\\n  convertLexicalToMarkdown,\\n  editorConfigFactory,\\n  lexicalEditor,\\n} from '@payloadcms/richtext-lexical'\\n\\nconst Pages: CollectionConfig = {\\n  slug: 'pages',\\n  fields: [\\n    {\\n      name: 'nameOfYourRichTextField',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n    {\\n      name: 'markdown',\\n      type: 'textarea',\\n      admin: {\\n        hidden: true,\\n      },\\n      hooks: {\\n        afterRead: [\\n          ({ siblingData, siblingFields }) =\u003e {\\n            const data: SerializedEditorState =\\n              siblingData['nameOfYourRichTextField']\\n\\n            if (!data) {\\n              return ''\\n            }\\n\\n            const markdown = convertLexicalToMarkdown({\\n              data,\\n              editorConfig: editorConfigFactory.fromField({\\n                field: siblingFields.find(\\n                  (field) =\u003e\\n                    'name' in field \u0026\u0026 field.name === 'nameOfYourRichTextField',\\n                ) as RichTextField,\\n              }),\\n            })\\n\\n            return markdown\\n          },\\n        ],\\n        beforeChange: [\\n          ({ siblingData }) =\u003e {\\n            // Ensure that the markdown field is not saved in the database\\n            delete siblingData['markdown']\\n            return null\\n          },\\n        ],\\n      },\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Converting Markdown to Richtext\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you have access to the Payload Config and the \", _jsx(_components.a, {\n        href: \"/docs/rich-text/converters#retrieving-the-editor-config\",\n        children: \"lexical editor config\"\n      }), \", you can convert Markdown to the lexical editor state with the following:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import {\\n  convertMarkdownToLexical,\\n  editorConfigFactory,\\n} from '@payloadcms/richtext-lexical'\\n\\nconst lexicalJSON = convertMarkdownToLexical({\\n  editorConfig: await editorConfigFactory.default({\\n    config, // \u003c= make sure you have access to your Payload Config\\n  }),\\n  markdown: '# Hello world\\\\n\\\\nThis is a **test**.',\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Converting MDX\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload supports serializing and deserializing MDX content. While Markdown converters are stored on the features, MDX converters are stored on the blocks that you pass to the \", _jsx(_components.code, {\n        children: \"BlocksFeature\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Defining a Custom Block\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of a \", _jsx(_components.code, {\n        children: \"Banner\"\n      }), \" block.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This block:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Renders in the admin UI as a normal Lexical block with specific fields (e.g. type, content).\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Converts to an MDX \", _jsx(_components.code, {\n          children: \"Banner\"\n        }), \" component.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Can parse that MDX \", _jsx(_components.code, {\n          children: \"Banner\"\n        }), \" back into a Lexical state.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(LightDarkImage, {\n      srcLight: \"https://payloadcms.com/images/docs/mdx-example-light.png\",\n      srcDark: \"https://payloadcms.com/images/docs/mdx-example-dark.png\",\n      alt: \"Shows the Banner field in a lexical editor and the MDX output\",\n      caption: \"Banner field in a lexical editor and the MDX output\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport type { Block, CollectionConfig, RichTextField } from 'payload'\\n\\nimport {\\n  BlocksFeature,\\n  convertLexicalToMarkdown,\\n  editorConfigFactory,\\n  lexicalEditor,\\n} from '@payloadcms/richtext-lexical'\\n\\nconst BannerBlock: Block = {\\n  slug: 'Banner',\\n  fields: [\\n    {\\n      name: 'type',\\n      type: 'select',\\n      defaultValue: 'info',\\n      options: [\\n        { label: 'Info', value: 'info' },\\n        { label: 'Warning', value: 'warning' },\\n        { label: 'Error', value: 'error' },\\n      ],\\n    },\\n    {\\n      name: 'content',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n  ],\\n  jsx: {\\n    /**\\n     * Convert from Lexical -\u003e MDX:\\n     * \u003cBanner type=\\\"...\\\" \u003echild content\u003c/Banner\u003e\\n     */\\n    export: ({ fields, lexicalToMarkdown }) =\u003e {\\n      const props: any = {}\\n      if (fields.type) {\\n        props.type = fields.type\\n      }\\n\\n      return {\\n        children: lexicalToMarkdown({ editorState: fields.content }),\\n        props,\\n      }\\n    },\\n    /**\\n     * Convert from MDX -\u003e Lexical:\\n     */\\n    import: ({ children, markdownToLexical, props }) =\u003e {\\n      return {\\n        type: props?.type,\\n        content: markdownToLexical({ markdown: children }),\\n      }\\n    },\\n  },\\n}\\n\\nconst Pages: CollectionConfig = {\\n  slug: 'pages',\\n  fields: [\\n    {\\n      name: 'nameOfYourRichTextField',\\n      type: 'richText',\\n      editor: lexicalEditor({\\n        features: ({ defaultFeatures }) =\u003e [\\n          ...defaultFeatures,\\n          BlocksFeature({\\n            blocks: [BannerBlock],\\n          }),\\n        ],\\n      }),\\n    },\\n    {\\n      name: 'markdown',\\n      type: 'textarea',\\n      hooks: {\\n        afterRead: [\\n          ({ siblingData, siblingFields }) =\u003e {\\n            const data: SerializedEditorState =\\n              siblingData['nameOfYourRichTextField']\\n\\n            if (!data) {\\n              return ''\\n            }\\n\\n            const markdown = convertLexicalToMarkdown({\\n              data,\\n              editorConfig: editorConfigFactory.fromField({\\n                field: siblingFields.find(\\n                  (field) =\u003e\\n                    'name' in field \u0026\u0026 field.name === 'nameOfYourRichTextField',\\n                ) as RichTextField,\\n              }),\\n            })\\n\\n            return markdown\\n          },\\n        ],\\n        beforeChange: [\\n          ({ siblingData }) =\u003e {\\n            // Ensure that the markdown field is not saved in the database\\n            delete siblingData['markdown']\\n            return null\\n          },\\n        ],\\n      },\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The conversion is done using the \", _jsx(_components.code, {\n        children: \"jsx\"\n      }), \" property of the block. The \", _jsx(_components.code, {\n        children: \"export\"\n      }), \" function is called when converting from lexical to MDX, and the \", _jsx(_components.code, {\n        children: \"import\"\n      }), \" function is called when converting from MDX to lexical.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Export\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"export\"\n      }), \" function takes the block field data and the \", _jsx(_components.code, {\n        children: \"lexicalToMarkdown\"\n      }), \" function as arguments. It returns the following object:\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Property\"\n          }), _jsx(_components.th, {\n            children: \"Type\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"children\"\n            })\n          }), _jsx(_components.td, {\n            children: \"string\"\n          }), _jsx(_components.td, {\n            children: \"This will be in between the opening and closing tags of the block.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"props\"\n            })\n          }), _jsx(_components.td, {\n            children: \"object\"\n          }), _jsx(_components.td, {\n            children: \"This will be in the opening tag of the block.\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Import\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"import\"\n      }), \" function provides data extracted from the MDX. It takes the following arguments:\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Argument\"\n          }), _jsx(_components.th, {\n            children: \"Type\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"children\"\n            })\n          }), _jsx(_components.td, {\n            children: \"string\"\n          }), _jsx(_components.td, {\n            children: \"This will be the text between the opening and closing tags of the block.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"props\"\n            })\n          }), _jsx(_components.td, {\n            children: \"object\"\n          }), _jsx(_components.td, {\n            children: \"These are the props passed to the block, parsed from the opening tag into an object.\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The returning object is equal to the block field data.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["rich-text","converting-markdown"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>