<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Converting JSX</h1><p class="text-xl text-gray-600 mb-8">Converting between lexical richtext and JSX</p><div class="prose prose-lg max-w-none"><h2>Converting Richtext to JSX</h2>
<p>To convert richtext to JSX, import the <code>RichText</code> component from <code>@payloadcms/richtext-lexical/react</code> and pass the richtext content to it:</p>
<pre><code class="language-tsx">import React from &#x27;react&#x27;
import { RichText } from &#x27;@payloadcms/richtext-lexical/react&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

export const MyComponent = ({ data }: { data: SerializedEditorState }) =&gt; {
  return &lt;RichText data={data} /&gt;
}
</code></pre>
<p>The <code>RichText</code> component includes built-in converters for common Lexical nodes. You can add or override converters via the <code>converters</code> prop for custom blocks, custom nodes, or any modifications you need. See the <a href="https://github.com/payloadcms/payload/blob/main/templates/website/src/components/RichText/index.tsx">website template</a> for a working example.</p>
<div class="p-4 my-4 rounded-lg border undefined"><p>When fetching data, ensure your <code>depth</code> setting is high enough to fully
populate Lexical nodes such as uploads. The JSX converter requires fully
populated data to work correctly.</p></div>
<h3>Converting Internal Links</h3>
<p>By default, Payload doesn&#x27;t know how to convert <strong>internal</strong> links to JSX, as it doesn&#x27;t know what the corresponding URL of the internal link is. You&#x27;ll notice that you get a &quot;found internal link, but internalDocToHref is not provided&quot; error in the console when you try to render content with internal links.</p>
<p>To fix this, you need to pass the <code>internalDocToHref</code> prop to <code>LinkJSXConverter</code>. This prop is a function that receives the link node and returns the URL of the document.</p>
<pre><code class="language-tsx">import type {
  DefaultNodeTypes,
  SerializedLinkNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import {
  type JSXConvertersFunction,
  LinkJSXConverter,
  RichText,
} from &#x27;@payloadcms/richtext-lexical/react&#x27;
import React from &#x27;react&#x27;

const internalDocToHref = ({ linkNode }: { linkNode: SerializedLinkNode }) =&gt; {
  const { relationTo, value } = linkNode.fields.doc!
  if (typeof value !== &#x27;object&#x27;) {
    throw new Error(&#x27;Expected value to be an object&#x27;)
  }
  const slug = value.slug

  switch (relationTo) {
    case &#x27;posts&#x27;:
      return `/posts/${slug}`
    case &#x27;categories&#x27;:
      return `/category/${slug}`
    case &#x27;pages&#x27;:
      return `/${slug}`
    default:
      return `/${relationTo}/${slug}`
  }
}

const jsxConverters: JSXConvertersFunction&lt;DefaultNodeTypes&gt; = ({
  defaultConverters,
}) =&gt; ({
  ...defaultConverters,
  ...LinkJSXConverter({ internalDocToHref }),
})

export const MyComponent: React.FC&lt;{
  lexicalData: SerializedEditorState
}&gt; = ({ lexicalData }) =&gt; {
  return &lt;RichText converters={jsxConverters} data={lexicalData} /&gt;
}
</code></pre>
<h3>Converting Lexical Blocks</h3>
<p>If your rich text includes custom Blocks or Inline Blocks, you must supply custom converters that match each block&#x27;s slug. This converter is not included by default, as Payload doesn&#x27;t know how to render your custom blocks.</p>
<p>For example:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;
import type { MyInlineBlock, MyNumberBlock, MyTextBlock } from &#x27;@/payload-types&#x27;
import type {
  DefaultNodeTypes,
  SerializedBlockNode,
  SerializedInlineBlockNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import {
  type JSXConvertersFunction,
  RichText,
} from &#x27;@payloadcms/richtext-lexical/react&#x27;
import React from &#x27;react&#x27;

// Extend the default node types with your custom blocks for full type safety
type NodeTypes =
  | DefaultNodeTypes
  | SerializedBlockNode&lt;MyNumberBlock | MyTextBlock&gt;
  | SerializedInlineBlockNode&lt;MyInlineBlock&gt;

const jsxConverters: JSXConvertersFunction&lt;NodeTypes&gt; = ({
  defaultConverters,
}) =&gt; ({
  ...defaultConverters,
  blocks: {
    // Each key should match your block&#x27;s slug
    myNumberBlock: ({ node }) =&gt; &lt;div&gt;{node.fields.number}&lt;/div&gt;,
    myTextBlock: ({ node }) =&gt; (
      &lt;div style={{ backgroundColor: &#x27;red&#x27; }}&gt;{node.fields.text}&lt;/div&gt;
    ),
  },
  inlineBlocks: {
    // Each key should match your inline block&#x27;s slug
    myInlineBlock: ({ node }) =&gt; &lt;span&gt;{node.fields.text}&lt;/span&gt;,
  },
})

export const MyComponent: React.FC&lt;{
  lexicalData: SerializedEditorState
}&gt; = ({ lexicalData }) =&gt; {
  return &lt;RichText converters={jsxConverters} data={lexicalData} /&gt;
}
</code></pre>
<h3>Overriding Default JSX Converters</h3>
<p>You can override any of the default JSX converters by passing passing your custom converter, keyed to the node type, to the <code>converters</code> prop / the converters function.</p>
<p>Example - overriding the upload node converter to use next/image:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;
import type {
  DefaultNodeTypes,
  SerializedUploadNode,
} from &#x27;@payloadcms/richtext-lexical&#x27;
import type { SerializedEditorState } from &#x27;@payloadcms/richtext-lexical/lexical&#x27;

import {
  type JSXConvertersFunction,
  RichText,
} from &#x27;@payloadcms/richtext-lexical/react&#x27;
import Image from &#x27;next/image&#x27;
import React from &#x27;react&#x27;

type NodeTypes = DefaultNodeTypes

// Custom upload converter component that uses next/image
const CustomUploadComponent: React.FC&lt;{
  node: SerializedUploadNode
}&gt; = ({ node }) =&gt; {
  if (node.relationTo === &#x27;uploads&#x27;) {
    const uploadDoc = node.value
    if (typeof uploadDoc !== &#x27;object&#x27;) {
      return null
    }
    const { alt, height, url, width } = uploadDoc
    return &lt;Image alt={alt} height={height} src={url} width={width} /&gt;
  }

  return null
}

const jsxConverters: JSXConvertersFunction&lt;NodeTypes&gt; = ({
  defaultConverters,
}) =&gt; ({
  ...defaultConverters,
  // Override the default upload converter
  upload: ({ node }) =&gt; {
    return &lt;CustomUploadComponent node={node} /&gt;
  },
})

export const MyComponent: React.FC&lt;{
  lexicalData: SerializedEditorState
}&gt; = ({ lexicalData }) =&gt; {
  return &lt;RichText converters={jsxConverters} data={lexicalData} /&gt;
}
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Converting JSX","label":"Converting JSX","order":21,"desc":"Converting between lexical richtext and JSX","keywords":"lexical, richtext, jsx"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Richtext to JSX\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To convert richtext to JSX, import the \", _jsx(_components.code, {\n        children: \"RichText\"\n      }), \" component from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/react\"\n      }), \" and pass the richtext content to it:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react'\\nimport { RichText } from '@payloadcms/richtext-lexical/react'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) =\u003e {\\n  return \u003cRichText data={data} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"RichText\"\n      }), \" component includes built-in converters for common Lexical nodes. You can add or override converters via the \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" prop for custom blocks, custom nodes, or any modifications you need. See the \", _jsx(_components.a, {\n        href: \"https://github.com/payloadcms/payload/blob/main/templates/website/src/components/RichText/index.tsx\",\n        children: \"website template\"\n      }), \" for a working example.\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"When fetching data, ensure your \", _jsx(_components.code, {\n          children: \"depth\"\n        }), \" setting is high enough to fully\\npopulate Lexical nodes such as uploads. The JSX converter requires fully\\npopulated data to work correctly.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Internal Links\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default, Payload doesn't know how to convert \", _jsx(_components.strong, {\n        children: \"internal\"\n      }), \" links to JSX, as it doesn't know what the corresponding URL of the internal link is. You'll notice that you get a \\\"found internal link, but internalDocToHref is not provided\\\" error in the console when you try to render content with internal links.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To fix this, you need to pass the \", _jsx(_components.code, {\n        children: \"internalDocToHref\"\n      }), \" prop to \", _jsx(_components.code, {\n        children: \"LinkJSXConverter\"\n      }), \". This prop is a function that receives the link node and returns the URL of the document.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type {\\n  DefaultNodeTypes,\\n  SerializedLinkNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  LinkJSXConverter,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport React from 'react'\\n\\nconst internalDocToHref = ({ linkNode }: { linkNode: SerializedLinkNode }) =\u003e {\\n  const { relationTo, value } = linkNode.fields.doc!\\n  if (typeof value !== 'object') {\\n    throw new Error('Expected value to be an object')\\n  }\\n  const slug = value.slug\\n\\n  switch (relationTo) {\\n    case 'posts':\\n      return `/posts/${slug}`\\n    case 'categories':\\n      return `/category/${slug}`\\n    case 'pages':\\n      return `/${slug}`\\n    default:\\n      return `/${relationTo}/${slug}`\\n  }\\n}\\n\\nconst jsxConverters: JSXConvertersFunction\u003cDefaultNodeTypes\u003e = ({\\n  defaultConverters,\\n}) =\u003e ({\\n  ...defaultConverters,\\n  ...LinkJSXConverter({ internalDocToHref }),\\n})\\n\\nexport const MyComponent: React.FC\u003c{\\n  lexicalData: SerializedEditorState\\n}\u003e = ({ lexicalData }) =\u003e {\\n  return \u003cRichText converters={jsxConverters} data={lexicalData} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Lexical Blocks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your rich text includes custom Blocks or Inline Blocks, you must supply custom converters that match each block's slug. This converter is not included by default, as Payload doesn't know how to render your custom blocks.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport type { MyInlineBlock, MyNumberBlock, MyTextBlock } from '@/payload-types'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n  SerializedInlineBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport React from 'react'\\n\\n// Extend the default node types with your custom blocks for full type safety\\ntype NodeTypes =\\n  | DefaultNodeTypes\\n  | SerializedBlockNode\u003cMyNumberBlock | MyTextBlock\u003e\\n  | SerializedInlineBlockNode\u003cMyInlineBlock\u003e\\n\\nconst jsxConverters: JSXConvertersFunction\u003cNodeTypes\u003e = ({\\n  defaultConverters,\\n}) =\u003e ({\\n  ...defaultConverters,\\n  blocks: {\\n    // Each key should match your block's slug\\n    myNumberBlock: ({ node }) =\u003e \u003cdiv\u003e{node.fields.number}\u003c/div\u003e,\\n    myTextBlock: ({ node }) =\u003e (\\n      \u003cdiv style={{ backgroundColor: 'red' }}\u003e{node.fields.text}\u003c/div\u003e\\n    ),\\n  },\\n  inlineBlocks: {\\n    // Each key should match your inline block's slug\\n    myInlineBlock: ({ node }) =\u003e \u003cspan\u003e{node.fields.text}\u003c/span\u003e,\\n  },\\n})\\n\\nexport const MyComponent: React.FC\u003c{\\n  lexicalData: SerializedEditorState\\n}\u003e = ({ lexicalData }) =\u003e {\\n  return \u003cRichText converters={jsxConverters} data={lexicalData} /\u003e\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Overriding Default JSX Converters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can override any of the default JSX converters by passing passing your custom converter, keyed to the node type, to the \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" prop / the converters function.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example - overriding the upload node converter to use next/image:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedUploadNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport Image from 'next/image'\\nimport React from 'react'\\n\\ntype NodeTypes = DefaultNodeTypes\\n\\n// Custom upload converter component that uses next/image\\nconst CustomUploadComponent: React.FC\u003c{\\n  node: SerializedUploadNode\\n}\u003e = ({ node }) =\u003e {\\n  if (node.relationTo === 'uploads') {\\n    const uploadDoc = node.value\\n    if (typeof uploadDoc !== 'object') {\\n      return null\\n    }\\n    const { alt, height, url, width } = uploadDoc\\n    return \u003cImage alt={alt} height={height} src={url} width={width} /\u003e\\n  }\\n\\n  return null\\n}\\n\\nconst jsxConverters: JSXConvertersFunction\u003cNodeTypes\u003e = ({\\n  defaultConverters,\\n}) =\u003e ({\\n  ...defaultConverters,\\n  // Override the default upload converter\\n  upload: ({ node }) =\u003e {\\n    return \u003cCustomUploadComponent node={node} /\u003e\\n  },\\n})\\n\\nexport const MyComponent: React.FC\u003c{\\n  lexicalData: SerializedEditorState\\n}\u003e = ({ lexicalData }) =\u003e {\\n  return \u003cRichText converters={jsxConverters} data={lexicalData} /\u003e\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["rich-text","converting-jsx"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>