<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Context</h1><p class="text-xl text-gray-600 mb-8">Context allows you to pass in extra data that can be shared between hooks</p><div class="prose prose-lg max-w-none"><p>The <code>context</code> object is used to share data across different Hooks. This persists throughout the entire lifecycle of a request and is available within every Hook. By setting properties to <code>req.context</code>, you can effectively share logic across multiple Hooks.</p>
<h2>When To Use Context</h2>
<p>Context gives you a way forward on otherwise difficult problems such as:</p>
<ol>
<li><strong>Passing data between Hooks</strong>: Needing data in multiple Hooks from a 3rd party API, it could be retrieved and used in <code>beforeChange</code> and later used again in an <code>afterChange</code> hook without having to fetch it twice.</li>
<li><strong>Preventing infinite loops</strong>: Calling <code>payload.update()</code> on the same document that triggered an <code>afterChange</code> hook will create an infinite loop, control the flow by assigning a no-op condition to context</li>
<li><strong>Passing data to Local API</strong>: Setting values on the <code>req.context</code> and pass it to <code>payload.create()</code> you can provide additional data to hooks without adding extraneous fields.</li>
<li><strong>Passing data between hooks and middleware or custom endpoints</strong>: Hooks could set context across multiple collections and then be used in a final <code>postMiddleware</code>.</li>
</ol>
<h2>How To Use Context</h2>
<p>Let&#x27;s see examples on how context can be used in the first two scenarios mentioned above:</p>
<h3>Passing Data Between Hooks</h3>
<p>To pass data between hooks, you can assign values to context in an earlier hook in the lifecycle of a request and expect it the context in a later hook.</p>
<p>For example:</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

const Customer: CollectionConfig = {
  slug: &#x27;customers&#x27;,
  hooks: {
    beforeChange: [
      async ({ context, data }) =&gt; {
        // assign the customerData to context for use later
        context.customerData = await fetchCustomerData(data.customerID)
        return {
          ...data,
          // some data we use here
          name: context.customerData.name,
        }
      },
    ],
    afterChange: [
      async ({ context, doc, req }) =&gt; {
        // use context.customerData without needing to fetch it again
        if (context.customerData.contacted === false) {
          createTodo(&#x27;Call Customer&#x27;, context.customerData)
        }
      },
    ],
  },
  fields: [
    /* ... */
  ],
}
</code></pre>
<h3>Preventing Infinite Loops</h3>
<p>Let&#x27;s say you have an <code>afterChange</code> hook, and you want to do a calculation inside the hook (as the document ID needed for the calculation is available in the <code>afterChange</code> hook, but not in the <code>beforeChange</code> hook). Once that&#x27;s done, you want to update the document with the result of the calculation.</p>
<p>Bad example:</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

const Customer: CollectionConfig = {
  slug: &#x27;customers&#x27;,
  hooks: {
    afterChange: [
      async ({ doc, req }) =&gt; {
        await req.payload.update({
          // DANGER: updating the same slug as the collection in an afterChange will create an infinite loop!
          collection: &#x27;customers&#x27;,
          id: doc.id,
          data: {
            ...(await fetchCustomerData(data.customerID)),
          },
        })
      },
    ],
  },
  fields: [
    /* ... */
  ],
}
</code></pre>
<p>Instead of the above, we need to tell the <code>afterChange</code> hook to not run again if it performs the update (and thus not update itself again). We can solve that with context.</p>
<p>Fixed example:</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

const MyCollection: CollectionConfig = {
  slug: &#x27;slug&#x27;,
  hooks: {
    afterChange: [
      async ({ context, doc, req }) =&gt; {
        // return if flag was previously set
        if (context.triggerAfterChange === false) {
          return
        }
        await req.payload.update({
          collection: contextHooksSlug,
          id: doc.id,
          data: {
            ...(await fetchCustomerData(data.customerID)),
          },
          context: {
            // set a flag to prevent from running again
            triggerAfterChange: false,
          },
        })
      },
    ],
  },
  fields: [
    /* ... */
  ],
}
</code></pre>
<h2>TypeScript</h2>
<p>The default TypeScript interface for <code>context</code> is <code>{ [key: string]: unknown }</code>. If you prefer a more strict typing in your project or when authoring plugins for others, you can override this using the <code>declare</code> syntax.</p>
<p>This is known as &quot;type augmentation&quot;, a TypeScript feature which allows us to add types to existing types. Simply put this in any <code>.ts</code> or <code>.d.ts</code> file:</p>
<pre><code class="language-ts">import { RequestContext as OriginalRequestContext } from &#x27;payload&#x27;

declare module &#x27;payload&#x27; {
  // Create a new interface that merges your additional fields with the original one
  export interface RequestContext extends OriginalRequestContext {
    myObject?: string
    // ...
  }
}
</code></pre>
<p>This will add the property <code>myObject</code> with a type of string to every context object. Make sure to follow this example correctly, as type augmentation can mess up your types if you do it wrong.</p></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Context","label":"Context","order":50,"desc":"Context allows you to pass in extra data that can be shared between hooks","keywords":"hooks, context, payload context, payloadcontext, data, extra data, shared data, shared, extra"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"context\"\n      }), \" object is used to share data across different Hooks. This persists throughout the entire lifecycle of a request and is available within every Hook. By setting properties to \", _jsx(_components.code, {\n        children: \"req.context\"\n      }), \", you can effectively share logic across multiple Hooks.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"When To Use Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Context gives you a way forward on otherwise difficult problems such as:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data between Hooks\"\n        }), \": Needing data in multiple Hooks from a 3rd party API, it could be retrieved and used in \", _jsx(_components.code, {\n          children: \"beforeChange\"\n        }), \" and later used again in an \", _jsx(_components.code, {\n          children: \"afterChange\"\n        }), \" hook without having to fetch it twice.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Preventing infinite loops\"\n        }), \": Calling \", _jsx(_components.code, {\n          children: \"payload.update()\"\n        }), \" on the same document that triggered an \", _jsx(_components.code, {\n          children: \"afterChange\"\n        }), \" hook will create an infinite loop, control the flow by assigning a no-op condition to context\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data to Local API\"\n        }), \": Setting values on the \", _jsx(_components.code, {\n          children: \"req.context\"\n        }), \" and pass it to \", _jsx(_components.code, {\n          children: \"payload.create()\"\n        }), \" you can provide additional data to hooks without adding extraneous fields.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data between hooks and middleware or custom endpoints\"\n        }), \": Hooks could set context across multiple collections and then be used in a final \", _jsx(_components.code, {\n          children: \"postMiddleware\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How To Use Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's see examples on how context can be used in the first two scenarios mentioned above:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Passing Data Between Hooks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To pass data between hooks, you can assign values to context in an earlier hook in the lifecycle of a request and expect it the context in a later hook.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst Customer: CollectionConfig = {\\n  slug: 'customers',\\n  hooks: {\\n    beforeChange: [\\n      async ({ context, data }) =\u003e {\\n        // assign the customerData to context for use later\\n        context.customerData = await fetchCustomerData(data.customerID)\\n        return {\\n          ...data,\\n          // some data we use here\\n          name: context.customerData.name,\\n        }\\n      },\\n    ],\\n    afterChange: [\\n      async ({ context, doc, req }) =\u003e {\\n        // use context.customerData without needing to fetch it again\\n        if (context.customerData.contacted === false) {\\n          createTodo('Call Customer', context.customerData)\\n        }\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Preventing Infinite Loops\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's say you have an \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook, and you want to do a calculation inside the hook (as the document ID needed for the calculation is available in the \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook, but not in the \", _jsx(_components.code, {\n        children: \"beforeChange\"\n      }), \" hook). Once that's done, you want to update the document with the result of the calculation.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bad example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst Customer: CollectionConfig = {\\n  slug: 'customers',\\n  hooks: {\\n    afterChange: [\\n      async ({ doc, req }) =\u003e {\\n        await req.payload.update({\\n          // DANGER: updating the same slug as the collection in an afterChange will create an infinite loop!\\n          collection: 'customers',\\n          id: doc.id,\\n          data: {\\n            ...(await fetchCustomerData(data.customerID)),\\n          },\\n        })\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead of the above, we need to tell the \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook to not run again if it performs the update (and thus not update itself again). We can solve that with context.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fixed example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst MyCollection: CollectionConfig = {\\n  slug: 'slug',\\n  hooks: {\\n    afterChange: [\\n      async ({ context, doc, req }) =\u003e {\\n        // return if flag was previously set\\n        if (context.triggerAfterChange === false) {\\n          return\\n        }\\n        await req.payload.update({\\n          collection: contextHooksSlug,\\n          id: doc.id,\\n          data: {\\n            ...(await fetchCustomerData(data.customerID)),\\n          },\\n          context: {\\n            // set a flag to prevent from running again\\n            triggerAfterChange: false,\\n          },\\n        })\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"TypeScript\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The default TypeScript interface for \", _jsx(_components.code, {\n        children: \"context\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"{ [key: string]: unknown }\"\n      }), \". If you prefer a more strict typing in your project or when authoring plugins for others, you can override this using the \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" syntax.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is known as \\\"type augmentation\\\", a TypeScript feature which allows us to add types to existing types. Simply put this in any \", _jsx(_components.code, {\n        children: \".ts\"\n      }), \" or \", _jsx(_components.code, {\n        children: \".d.ts\"\n      }), \" file:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { RequestContext as OriginalRequestContext } from 'payload'\\n\\ndeclare module 'payload' {\\n  // Create a new interface that merges your additional fields with the original one\\n  export interface RequestContext extends OriginalRequestContext {\\n    myObject?: string\\n    // ...\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This will add the property \", _jsx(_components.code, {\n        children: \"myObject\"\n      }), \" with a type of string to every context object. Make sure to follow this example correctly, as type augmentation can mess up your types if you do it wrong.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["hooks","context"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>