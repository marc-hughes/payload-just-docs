<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Server-side Live Preview</h1><p class="text-xl text-gray-600 mb-8">Learn how to implement Live Preview in your server-side front-end application.</p><div class="prose prose-lg max-w-none"><div class="p-4 my-4 rounded-lg border bg-blue-50 border-blue-200 text-blue-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg><p>Server-side Live Preview is only for front-end frameworks that support the
concept of Server Components, i.e. <a href="https://react.dev/reference/rsc/server-components">React Server
Components</a>. If your
front-end application is built with a client-side framework like the <a href="https://nextjs.org/docs/pages">Next.js
Pages Router</a>, <a href="https://reactrouter.com">React
Router</a>, <a href="https://vuejs.org">Vue 3</a>, etc., see
<a href="./client">client-side Live Preview</a>.</p></div>
<p>Server-side Live Preview works by making a roundtrip to the server every time your document is saved, i.e. draft save, autosave, or publish. While using Live Preview, the Admin Panel emits a new <code>window.postMessage</code> event which your front-end application can use to invoke this process. In Next.js, this means simply calling <code>router.refresh()</code> which will hydrate the HTML using new data straight from the <a href="../local-api/overview">Local API</a>.</p>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p>It is recommended that you enable <a href="../versions/autosave">Autosave</a> alongside
Live Preview to make the experience feel more responsive.</p></div>
<p>If your front-end application is built with <a href="#react">React</a>, you can use the <code>RefreshRouteOnChange</code> function that Payload provides. In the future, all other major frameworks like Vue and Svelte will be officially supported. If you are using any of these frameworks today, you can still integrate with Live Preview yourself using the underlying tooling that Payload provides. See <a href="#building-your-own-router-refresh-component">building your own router refresh component</a> for more information.</p>
<h2>React</h2>
<p>If your front-end application is built with server-side <a href="https://react.dev">React</a> like <a href="https://nextjs.org/docs/app">Next.js App Router</a>, you can use the <code>RefreshRouteOnSave</code> component that Payload provides.</p>
<p>First, install the <code>@payloadcms/live-preview-react</code> package:</p>
<pre><code class="language-bash">npm install @payloadcms/live-preview-react
</code></pre>
<p>Then, render the <code>RefreshRouteOnSave</code> component anywhere in your <code>page.tsx</code>. Here&#x27;s an example:</p>
<p><code>page.tsx</code>:</p>
<pre><code class="language-tsx">import { RefreshRouteOnSave } from &#x27;./RefreshRouteOnSave.tsx&#x27;
import { getPayload } from &#x27;payload&#x27;
import config from &#x27;../payload.config&#x27;

export default async function Page() {
  const payload = await getPayload({ config })

  const page = await payload.findByID({
    collection: &#x27;pages&#x27;,
    id: &#x27;123&#x27;,
    draft: true,
  })

  return (
    &lt;Fragment&gt;
      &lt;RefreshRouteOnSave /&gt;
      &lt;h1&gt;{page.title}&lt;/h1&gt;
    &lt;/Fragment&gt;
  )
}
</code></pre>
<p><code>RefreshRouteOnSave.tsx</code>:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;
import { RefreshRouteOnSave as PayloadLivePreview } from &#x27;@payloadcms/live-preview-react&#x27;
import { useRouter } from &#x27;next/navigation.js&#x27;
import React from &#x27;react&#x27;

export const RefreshRouteOnSave: React.FC = () =&gt; {
  const router = useRouter()

  return (
    &lt;PayloadLivePreview
      refresh={() =&gt; router.refresh()}
      serverURL={process.env.NEXT_PUBLIC_PAYLOAD_URL}
    /&gt;
  )
}
</code></pre>
<h2>Building your own router refresh component</h2>
<p>No matter what front-end framework you are using, you can build your own component using the same underlying tooling that Payload provides.</p>
<p>First, install the base <code>@payloadcms/live-preview</code> package:</p>
<pre><code class="language-bash">npm install @payloadcms/live-preview
</code></pre>
<p>This package provides the following functions:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Path</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><strong><code>ready</code></strong></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Sends a <code>window.postMessage</code> event to the Admin Panel to indicate that the front-end is ready to receive messages.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><strong><code>isDocumentEvent</code></strong></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Checks if a <code>MessageEvent</code> originates from the Admin Panel and is a document-level event, i.e. draft save, autosave, publish, etc.</td></tr></tbody></table></div>
<p>With these functions, you can build your own hook using your front-end framework of choice:</p>
<pre><code class="language-tsx">import { ready, isDocumentEvent } from &#x27;@payloadcms/live-preview&#x27;

// To build your own component:
// 1. Listen for document-level `window.postMessage` events sent from the Admin Panel
// 2. Tell the Admin Panel when it is ready to receive messages
// 3. Refresh the route every time a new document-level event is received
// 4. Unsubscribe from the `window.postMessage` events when it unmounts
</code></pre>
<p>Here is an example of what the same <code>RefreshRouteOnSave</code> React component from above looks like under the hood:</p>
<pre><code class="language-tsx">&#x27;use client&#x27;

import type React from &#x27;react&#x27;

import { isDocumentEvent, ready } from &#x27;@payloadcms/live-preview&#x27;
import { useCallback, useEffect, useRef } from &#x27;react&#x27;

export const RefreshRouteOnSave: React.FC&lt;{
  apiRoute?: string
  depth?: number
  refresh: () =&gt; void
  serverURL: string
}&gt; = (props) =&gt; {
  const { apiRoute, depth, refresh, serverURL } = props
  const hasSentReadyMessage = useRef&lt;boolean&gt;(false)

  const onMessage = useCallback(
    (event: MessageEvent) =&gt; {
      if (isDocumentEvent(event, serverURL)) {
        if (typeof refresh === &#x27;function&#x27;) {
          refresh()
        }
      }
    },
    [refresh, serverURL],
  )

  useEffect(() =&gt; {
    if (typeof window !== &#x27;undefined&#x27;) {
      window.addEventListener(&#x27;message&#x27;, onMessage)
    }

    if (!hasSentReadyMessage.current) {
      hasSentReadyMessage.current = true

      ready({
        serverURL,
      })
    }

    return () =&gt; {
      if (typeof window !== &#x27;undefined&#x27;) {
        window.removeEventListener(&#x27;message&#x27;, onMessage)
      }
    }
  }, [serverURL, onMessage, depth, apiRoute])

  return null
}
</code></pre>
<h2>Example</h2>
<p>For a working demonstration of this, check out the official <a href="https://github.com/payloadcms/payload/tree/main/examples/live-preview">Live Preview Example</a>. There you will find a fully working example of how to implement Live Preview in your Next.js App Router application.</p>
<h2>Troubleshooting</h2>
<h4>Updates do not appear as fast as client-side Live Preview</h4>
<p>If you are noticing that updates feel less snappy than client-side Live Preview (i.e. the <code>useLivePreview</code> hook), this is because of how the two differ in how they workâ€”instead of emitting events against <em>form state</em>, server-side Live Preview refreshes the route after a new document is <em>saved</em>.</p>
<p>Use <a href="../versions/autosave">Autosave</a> to mimic this effect server-side. Try decreasing the value of <code>versions.autoSave.interval</code> to make the experience feel more responsive:</p>
<pre><code class="language-ts">// collection.ts
{
   versions: {
    drafts: {
      autosave: {
        interval: 375,
      },
    },
  },
}
</code></pre>
<h4>Iframe refuses to connect</h4>
<p>If your front-end application has set a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy</a> (CSP) that blocks the Admin Panel from loading your front-end application, the iframe will not be able to load your site. To resolve this, you can whitelist the Admin Panel&#x27;s domain in your CSP by setting the <code>frame-ancestors</code> directive:</p>
<pre><code class="language-plaintext">frame-ancestors: &quot;self&quot; localhost:* https://your-site.com;
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Server-side Live Preview","label":"Server-side","order":30,"desc":"Learn how to implement Live Preview in your server-side front-end application.","keywords":"live preview, frontend, react, next.js, vue, nuxt.js, svelte, hook, useLivePreview"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    pre: \"pre\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    strong: \"strong\",\n    h4: \"h4\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Banner, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"Server-side Live Preview is only for front-end frameworks that support the\\nconcept of Server Components, i.e. \", _jsx(_components.a, {\n          href: \"https://react.dev/reference/rsc/server-components\",\n          children: \"React Server\\nComponents\"\n        }), \". If your\\nfront-end application is built with a client-side framework like the \", _jsx(_components.a, {\n          href: \"https://nextjs.org/docs/pages\",\n          children: \"Next.js\\nPages Router\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://reactrouter.com\",\n          children: \"React\\nRouter\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://vuejs.org\",\n          children: \"Vue 3\"\n        }), \", etc., see\\n\", _jsx(_components.a, {\n          href: \"./client\",\n          children: \"client-side Live Preview\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Server-side Live Preview works by making a roundtrip to the server every time your document is saved, i.e. draft save, autosave, or publish. While using Live Preview, the Admin Panel emits a new \", _jsx(_components.code, {\n        children: \"window.postMessage\"\n      }), \" event which your front-end application can use to invoke this process. In Next.js, this means simply calling \", _jsx(_components.code, {\n        children: \"router.refresh()\"\n      }), \" which will hydrate the HTML using new data straight from the \", _jsx(_components.a, {\n        href: \"../local-api/overview\",\n        children: \"Local API\"\n      }), \".\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"It is recommended that you enable \", _jsx(_components.a, {\n          href: \"../versions/autosave\",\n          children: \"Autosave\"\n        }), \" alongside\\nLive Preview to make the experience feel more responsive.\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application is built with \", _jsx(_components.a, {\n        href: \"#react\",\n        children: \"React\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnChange\"\n      }), \" function that Payload provides. In the future, all other major frameworks like Vue and Svelte will be officially supported. If you are using any of these frameworks today, you can still integrate with Live Preview yourself using the underlying tooling that Payload provides. See \", _jsx(_components.a, {\n        href: \"#building-your-own-router-refresh-component\",\n        children: \"building your own router refresh component\"\n      }), \" for more information.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application is built with server-side \", _jsx(_components.a, {\n        href: \"https://react.dev\",\n        children: \"React\"\n      }), \" like \", _jsx(_components.a, {\n        href: \"https://nextjs.org/docs/app\",\n        children: \"Next.js App Router\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" component that Payload provides.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, install the \", _jsx(_components.code, {\n        children: \"@payloadcms/live-preview-react\"\n      }), \" package:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install @payloadcms/live-preview-react\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, render the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" component anywhere in your \", _jsx(_components.code, {\n        children: \"page.tsx\"\n      }), \". Here's an example:\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"page.tsx\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { RefreshRouteOnSave } from './RefreshRouteOnSave.tsx'\\nimport { getPayload } from 'payload'\\nimport config from '../payload.config'\\n\\nexport default async function Page() {\\n  const payload = await getPayload({ config })\\n\\n  const page = await payload.findByID({\\n    collection: 'pages',\\n    id: '123',\\n    draft: true,\\n  })\\n\\n  return (\\n    \u003cFragment\u003e\\n      \u003cRefreshRouteOnSave /\u003e\\n      \u003ch1\u003e{page.title}\u003c/h1\u003e\\n    \u003c/Fragment\u003e\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"RefreshRouteOnSave.tsx\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport { RefreshRouteOnSave as PayloadLivePreview } from '@payloadcms/live-preview-react'\\nimport { useRouter } from 'next/navigation.js'\\nimport React from 'react'\\n\\nexport const RefreshRouteOnSave: React.FC = () =\u003e {\\n  const router = useRouter()\\n\\n  return (\\n    \u003cPayloadLivePreview\\n      refresh={() =\u003e router.refresh()}\\n      serverURL={process.env.NEXT_PUBLIC_PAYLOAD_URL}\\n    /\u003e\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Building your own router refresh component\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No matter what front-end framework you are using, you can build your own component using the same underlying tooling that Payload provides.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, install the base \", _jsx(_components.code, {\n        children: \"@payloadcms/live-preview\"\n      }), \" package:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install @payloadcms/live-preview\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This package provides the following functions:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Path\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"ready\"\n              })\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Sends a \", _jsx(_components.code, {\n              children: \"window.postMessage\"\n            }), \" event to the Admin Panel to indicate that the front-end is ready to receive messages.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"isDocumentEvent\"\n              })\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Checks if a \", _jsx(_components.code, {\n              children: \"MessageEvent\"\n            }), \" originates from the Admin Panel and is a document-level event, i.e. draft save, autosave, publish, etc.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With these functions, you can build your own hook using your front-end framework of choice:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { ready, isDocumentEvent } from '@payloadcms/live-preview'\\n\\n// To build your own component:\\n// 1. Listen for document-level `window.postMessage` events sent from the Admin Panel\\n// 2. Tell the Admin Panel when it is ready to receive messages\\n// 3. Refresh the route every time a new document-level event is received\\n// 4. Unsubscribe from the `window.postMessage` events when it unmounts\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of what the same \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" React component from above looks like under the hood:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type React from 'react'\\n\\nimport { isDocumentEvent, ready } from '@payloadcms/live-preview'\\nimport { useCallback, useEffect, useRef } from 'react'\\n\\nexport const RefreshRouteOnSave: React.FC\u003c{\\n  apiRoute?: string\\n  depth?: number\\n  refresh: () =\u003e void\\n  serverURL: string\\n}\u003e = (props) =\u003e {\\n  const { apiRoute, depth, refresh, serverURL } = props\\n  const hasSentReadyMessage = useRef\u003cboolean\u003e(false)\\n\\n  const onMessage = useCallback(\\n    (event: MessageEvent) =\u003e {\\n      if (isDocumentEvent(event, serverURL)) {\\n        if (typeof refresh === 'function') {\\n          refresh()\\n        }\\n      }\\n    },\\n    [refresh, serverURL],\\n  )\\n\\n  useEffect(() =\u003e {\\n    if (typeof window !== 'undefined') {\\n      window.addEventListener('message', onMessage)\\n    }\\n\\n    if (!hasSentReadyMessage.current) {\\n      hasSentReadyMessage.current = true\\n\\n      ready({\\n        serverURL,\\n      })\\n    }\\n\\n    return () =\u003e {\\n      if (typeof window !== 'undefined') {\\n        window.removeEventListener('message', onMessage)\\n      }\\n    }\\n  }, [serverURL, onMessage, depth, apiRoute])\\n\\n  return null\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For a working demonstration of this, check out the official \", _jsx(_components.a, {\n        href: \"https://github.com/payloadcms/payload/tree/main/examples/live-preview\",\n        children: \"Live Preview Example\"\n      }), \". There you will find a fully working example of how to implement Live Preview in your Next.js App Router application.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Troubleshooting\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Updates do not appear as fast as client-side Live Preview\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are noticing that updates feel less snappy than client-side Live Preview (i.e. the \", _jsx(_components.code, {\n        children: \"useLivePreview\"\n      }), \" hook), this is because of how the two differ in how they workâ€”instead of emitting events against \", _jsx(_components.em, {\n        children: \"form state\"\n      }), \", server-side Live Preview refreshes the route after a new document is \", _jsx(_components.em, {\n        children: \"saved\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use \", _jsx(_components.a, {\n        href: \"../versions/autosave\",\n        children: \"Autosave\"\n      }), \" to mimic this effect server-side. Try decreasing the value of \", _jsx(_components.code, {\n        children: \"versions.autoSave.interval\"\n      }), \" to make the experience feel more responsive:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// collection.ts\\n{\\n   versions: {\\n    drafts: {\\n      autosave: {\\n        interval: 375,\\n      },\\n    },\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Iframe refuses to connect\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application has set a \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\",\n        children: \"Content Security Policy\"\n      }), \" (CSP) that blocks the Admin Panel from loading your front-end application, the iframe will not be able to load your site. To resolve this, you can whitelist the Admin Panel's domain in your CSP by setting the \", _jsx(_components.code, {\n        children: \"frame-ancestors\"\n      }), \" directive:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: \"frame-ancestors: \\\"self\\\" localhost:* https://your-site.com;\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["live-preview","server"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>