<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Overview - Querying your Documents | Payload CMS Documentation</title><meta name="description" content="Payload provides a querying language through all APIs, allowing you to filter or search through documents within a Collection."/><meta property="og:title" content="Overview - Querying your Documents | Payload CMS Documentation"/><meta property="og:description" content="Payload provides a querying language through all APIs, allowing you to filter or search through documents within a Collection."/><meta name="next-head-count" content="6"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-8726031e66a50318.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/_tTBTu5tMI_qrBgEpmt0H/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/_tTBTu5tMI_qrBgEpmt0H/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Querying your Documents</h1><p class="text-xl text-gray-600 mb-8">Payload provides a querying language through all APIs, allowing you to filter or search through documents within a Collection.</p><div class="prose prose-lg max-w-none"><p>In Payload, &quot;querying&quot; means filtering or searching through Documents within a <a href="../configuration/collections">Collection</a>. The querying language in Payload is designed to be simple and powerful, allowing you to filter Documents with extreme precision through an intuitive and standardized structure.</p>
<p>Payload provides three common APIs for querying your data:</p>
<ul>
<li><a href="/payload-just-docs/docs/local-api/overview">Local API</a> - Extremely fast, direct-to-database access</li>
<li><a href="/payload-just-docs/docs/rest-api/overview">REST API</a> - Standard HTTP endpoints for querying and mutating data</li>
<li><a href="/payload-just-docs/docs/graphql/overview">GraphQL</a> - A full GraphQL API with a GraphQL Playground</li>
</ul>
<p>Each of these APIs share the same underlying querying language, and fully support all of the same features. This means that you can learn Payload&#x27;s querying language once, and use it across any of the APIs that you might use.</p>
<p>To query your Documents, you can send any number of <a href="#operators">Operators</a> through your request:</p>
<pre><code class="language-ts">import type { Where } from &#x27;payload&#x27;

const query: Where = {
  color: {
    equals: &#x27;blue&#x27;,
  },
}
</code></pre>
<p><em>The exact query syntax will depend on the API you are using, but the concepts are the same across all APIs. <a href="#writing-queries">More details</a>.</em></p>
<div class="p-4 my-4 rounded-lg border bg-blue-50 border-blue-200 text-blue-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg><p><strong>Tip:</strong> You can also use queries within <a href="../access-control/overview">Access
Control</a> functions.</p></div>
<h2>Operators</h2>
<p>The following operators are available for use in queries:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Operator</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>equals</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The value must be exactly equal.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>not_equals</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The query will return all documents where the value is not equal.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>greater_than</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For numeric or date-based fields.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>greater_than_equal</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For numeric or date-based fields.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>less_than</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For numeric or date-based fields.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>less_than_equal</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For numeric or date-based fields.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>like</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Case-insensitive string must be present. If string of words, all words must be present, in any order.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>contains</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Must contain the value entered, case-insensitive.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>in</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The value must be found within the provided comma-delimited list of values.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>not_in</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The value must NOT be within the provided comma-delimited list of values.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>all</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The value must contain all values provided in the comma-delimited list. Note: currently this operator is supported only with the MongoDB adapter.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>exists</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Only return documents where the value either exists (<code>true</code>) or does not exist (<code>false</code>).</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>near</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For distance related to a <a href="../fields/point">Point Field</a> comma separated as <code>&lt;longitude&gt;, &lt;latitude&gt;, &lt;maxDistance in meters (nullable)&gt;, &lt;minDistance in meters (nullable)&gt;</code>.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>within</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For <a href="../fields/point">Point Fields</a> to filter documents based on whether points are inside of the given area defined in GeoJSON. <a href="../fields/point#querying-within">Example</a></td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>intersects</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">For <a href="../fields/point">Point Fields</a> to filter documents based on whether points intersect with the given area defined in GeoJSON. <a href="../fields/point#querying-intersects">Example</a></td></tr></tbody></table></div>
<div class="p-4 my-4 rounded-lg border bg-green-50 border-green-200 text-green-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg><p><strong>Tip:</strong> If you know your users will be querying on certain fields a lot, add
<code>index: true</code> to the Field Config. This will speed up searches using that
field immensely.</p></div>
<h3>And / Or Logic</h3>
<p>In addition to defining simple queries, you can join multiple queries together using AND / OR logic. These can be nested as deeply as you need to create complex queries.</p>
<p>To join queries, use the <code>and</code> or <code>or</code> keys in your query object:</p>
<pre><code class="language-ts">import type { Where } from &#x27;payload&#x27;

const query: Where = {
  or: [
    // highlight-line
    {
      color: {
        equals: &#x27;mint&#x27;,
      },
    },
    {
      and: [
        // highlight-line
        {
          color: {
            equals: &#x27;white&#x27;,
          },
        },
        {
          featured: {
            equals: false,
          },
        },
      ],
    },
  ],
}
</code></pre>
<p>Written in plain English, if the above query were passed to a <code>find</code> operation, it would translate to finding posts where either the <code>color</code> is <code>mint</code> OR the <code>color</code> is <code>white</code> AND <code>featured</code> is set to false.</p>
<h3>Nested properties</h3>
<p>When working with nested properties, which can happen when using relational fields, it is possible to use the dot notation to access the nested property. For example, when working with a <code>Song</code> collection that has a <code>artists</code> field which is related to an <code>Artists</code> collection using the <code>name: &#x27;artists&#x27;</code>. You can access a property within the collection <code>Artists</code> like so:</p>
<pre><code class="language-js">import type { Where } from &#x27;payload&#x27;

const query: Where = {
  &#x27;artists.featured&#x27;: {
    // nested property name to filter on
    exists: true, // operator to use and boolean value that needs to be true
  },
}
</code></pre>
<h2>Writing Queries</h2>
<p>Writing queries in Payload is simple and consistent across all APIs, with only minor differences in syntax between them.</p>
<h3>Local API</h3>
<p>The <a href="../local-api/overview">Local API</a> supports the <code>find</code> operation that accepts a raw query object:</p>
<pre><code class="language-ts">import type { Payload } from &#x27;payload&#x27;

const getPosts = async (payload: Payload) =&gt; {
  const posts = await payload.find({
    collection: &#x27;posts&#x27;,
    where: {
      color: {
        equals: &#x27;mint&#x27;,
      },
    },
  })

  return posts
}
</code></pre>
<h3>GraphQL API</h3>
<p>All <code>find</code> queries in the <a href="../graphql/overview">GraphQL API</a> support the <code>where</code> argument that accepts a raw query object:</p>
<pre><code class="language-ts">query {
  Posts(where: { color: { equals: mint } }) {
    docs {
      color
    }
    totalDocs
  }
}
</code></pre>
<h3>REST API</h3>
<p>With the <a href="../rest-api/overview">REST API</a>, you can use the full power of Payload queries, but they are written as query strings instead:</p>
<p><strong><code>https://localhost:3000/api/posts?where[color][equals]=mint</code></strong></p>
<p>To understand the syntax, you need to understand that complex URL search strings are parsed into a JSON object. This one isn&#x27;t too bad, but more complex queries get unavoidably more difficult to write.</p>
<p>For this reason, we recommend to use the extremely helpful and ubiquitous <a href="https://www.npmjs.com/package/qs-esm"><code>qs-esm</code></a> package to parse your JSON / object-formatted queries into query strings:</p>
<pre><code class="language-ts">import { stringify } from &#x27;qs-esm&#x27;
import type { Where } from &#x27;payload&#x27;

const query: Where = {
  color: {
    equals: &#x27;mint&#x27;,
  },
  // This query could be much more complex
  // and qs-esm would handle it beautifully
}

const getPosts = async () =&gt; {
  const stringifiedQuery = stringify(
    {
      where: query, // ensure that `qs-esm` adds the `where` property, too!
    },
    { addQueryPrefix: true },
  )

  const response = await fetch(
    `http://localhost:3000/api/posts${stringifiedQuery}`,
  )
  // Continue to handle the response below...
}
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Querying your Documents","label":"Overview","order":10,"desc":"Payload provides a querying language through all APIs, allowing you to filter or search through documents within a Collection.","keywords":"query, documents, overview, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    strong: \"strong\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In Payload, \\\"querying\\\" means filtering or searching through Documents within a \", _jsx(_components.a, {\n        href: \"../configuration/collections\",\n        children: \"Collection\"\n      }), \". The querying language in Payload is designed to be simple and powerful, allowing you to filter Documents with extreme precision through an intuitive and standardized structure.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Payload provides three common APIs for querying your data:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/local-api/overview\",\n          children: \"Local API\"\n        }), \" - Extremely fast, direct-to-database access\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/rest-api/overview\",\n          children: \"REST API\"\n        }), \" - Standard HTTP endpoints for querying and mutating data\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/graphql/overview\",\n          children: \"GraphQL\"\n        }), \" - A full GraphQL API with a GraphQL Playground\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each of these APIs share the same underlying querying language, and fully support all of the same features. This means that you can learn Payload's querying language once, and use it across any of the APIs that you might use.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To query your Documents, you can send any number of \", _jsx(_components.a, {\n        href: \"#operators\",\n        children: \"Operators\"\n      }), \" through your request:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  color: {\\n    equals: 'blue',\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"The exact query syntax will depend on the API you are using, but the concepts are the same across all APIs. \", _jsx(_components.a, {\n          href: \"#writing-queries\",\n          children: \"More details\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsx(Banner, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" You can also use queries within \", _jsx(_components.a, {\n          href: \"../access-control/overview\",\n          children: \"Access\\nControl\"\n        }), \" functions.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Operators\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following operators are available for use in queries:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Operator\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"equals\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must be exactly equal.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"not_equals\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The query will return all documents where the value is not equal.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"greater_than\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"greater_than_equal\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"less_than\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"less_than_equal\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"like\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Case-insensitive string must be present. If string of words, all words must be present, in any order.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"contains\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Must contain the value entered, case-insensitive.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"in\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must be found within the provided comma-delimited list of values.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"not_in\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must NOT be within the provided comma-delimited list of values.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"all\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must contain all values provided in the comma-delimited list. Note: currently this operator is supported only with the MongoDB adapter.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"exists\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Only return documents where the value either exists (\", _jsx(_components.code, {\n              children: \"true\"\n            }), \") or does not exist (\", _jsx(_components.code, {\n              children: \"false\"\n            }), \").\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"near\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For distance related to a \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Field\"\n            }), \" comma separated as \", _jsx(_components.code, {\n              children: \"\u003clongitude\u003e, \u003clatitude\u003e, \u003cmaxDistance in meters (nullable)\u003e, \u003cminDistance in meters (nullable)\u003e\"\n            }), \".\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"within\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Fields\"\n            }), \" to filter documents based on whether points are inside of the given area defined in GeoJSON. \", _jsx(_components.a, {\n              href: \"../fields/point#querying-within\",\n              children: \"Example\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"intersects\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Fields\"\n            }), \" to filter documents based on whether points intersect with the given area defined in GeoJSON. \", _jsx(_components.a, {\n              href: \"../fields/point#querying-intersects\",\n              children: \"Example\"\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" If you know your users will be querying on certain fields a lot, add\\n\", _jsx(_components.code, {\n          children: \"index: true\"\n        }), \" to the Field Config. This will speed up searches using that\\nfield immensely.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"And / Or Logic\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In addition to defining simple queries, you can join multiple queries together using AND / OR logic. These can be nested as deeply as you need to create complex queries.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To join queries, use the \", _jsx(_components.code, {\n        children: \"and\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"or\"\n      }), \" keys in your query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  or: [\\n    // highlight-line\\n    {\\n      color: {\\n        equals: 'mint',\\n      },\\n    },\\n    {\\n      and: [\\n        // highlight-line\\n        {\\n          color: {\\n            equals: 'white',\\n          },\\n        },\\n        {\\n          featured: {\\n            equals: false,\\n          },\\n        },\\n      ],\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Written in plain English, if the above query were passed to a \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" operation, it would translate to finding posts where either the \", _jsx(_components.code, {\n        children: \"color\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"mint\"\n      }), \" OR the \", _jsx(_components.code, {\n        children: \"color\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"white\"\n      }), \" AND \", _jsx(_components.code, {\n        children: \"featured\"\n      }), \" is set to false.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Nested properties\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When working with nested properties, which can happen when using relational fields, it is possible to use the dot notation to access the nested property. For example, when working with a \", _jsx(_components.code, {\n        children: \"Song\"\n      }), \" collection that has a \", _jsx(_components.code, {\n        children: \"artists\"\n      }), \" field which is related to an \", _jsx(_components.code, {\n        children: \"Artists\"\n      }), \" collection using the \", _jsx(_components.code, {\n        children: \"name: 'artists'\"\n      }), \". You can access a property within the collection \", _jsx(_components.code, {\n        children: \"Artists\"\n      }), \" like so:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  'artists.featured': {\\n    // nested property name to filter on\\n    exists: true, // operator to use and boolean value that needs to be true\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Writing Queries\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Writing queries in Payload is simple and consistent across all APIs, with only minor differences in syntax between them.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Local API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"../local-api/overview\",\n        children: \"Local API\"\n      }), \" supports the \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" operation that accepts a raw query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Payload } from 'payload'\\n\\nconst getPosts = async (payload: Payload) =\u003e {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    where: {\\n      color: {\\n        equals: 'mint',\\n      },\\n    },\\n  })\\n\\n  return posts\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"GraphQL API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" queries in the \", _jsx(_components.a, {\n        href: \"../graphql/overview\",\n        children: \"GraphQL API\"\n      }), \" support the \", _jsx(_components.code, {\n        children: \"where\"\n      }), \" argument that accepts a raw query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"query {\\n  Posts(where: { color: { equals: mint } }) {\\n    docs {\\n      color\\n    }\\n    totalDocs\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"REST API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With the \", _jsx(_components.a, {\n        href: \"../rest-api/overview\",\n        children: \"REST API\"\n      }), \", you can use the full power of Payload queries, but they are written as query strings instead:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"https://localhost:3000/api/posts?where[color][equals]=mint\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To understand the syntax, you need to understand that complex URL search strings are parsed into a JSON object. This one isn't too bad, but more complex queries get unavoidably more difficult to write.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For this reason, we recommend to use the extremely helpful and ubiquitous \", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/qs-esm\",\n        children: _jsx(_components.code, {\n          children: \"qs-esm\"\n        })\n      }), \" package to parse your JSON / object-formatted queries into query strings:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { stringify } from 'qs-esm'\\nimport type { Where } from 'payload'\\n\\nconst query: Where = {\\n  color: {\\n    equals: 'mint',\\n  },\\n  // This query could be much more complex\\n  // and qs-esm would handle it beautifully\\n}\\n\\nconst getPosts = async () =\u003e {\\n  const stringifiedQuery = stringify(\\n    {\\n      where: query, // ensure that `qs-esm` adds the `where` property, too!\\n    },\\n    { addQueryPrefix: true },\\n  )\\n\\n  const response = await fetch(\\n    `http://localhost:3000/api/posts${stringifiedQuery}`,\\n  )\\n  // Continue to handle the response below...\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["queries","overview"]},"buildId":"_tTBTu5tMI_qrBgEpmt0H","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>