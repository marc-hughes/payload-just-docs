<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/pbayt_BRhSN28J-gcoKlf/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Select</h1><p class="text-xl text-gray-600 mb-8">Payload select determines which fields are selected to the result.</p><div class="prose prose-lg max-w-none"><p>By default, Payload&#x27;s APIs will return <em>all fields</em> for a given collection or global. But, you may not need all of that data for all of your queries. Sometimes, you might want just a few fields from the response, which can speed up the Payload API and reduce the amount of JSON that is sent to you from the API.</p>
<p>This is where Payload&#x27;s <code>select</code> feature comes in. Here, you can define exactly which fields you&#x27;d like to retrieve from the API.</p>
<h2>Local API</h2>
<p>To specify <code>select</code> in the <a href="../local-api/overview">Local API</a>, you can use the <code>select</code> option in your query:</p>
<pre><code class="language-ts">import type { Payload } from &#x27;payload&#x27;

// Include mode
const getPosts = async (payload: Payload) =&gt; {
  const posts = await payload.find({
    collection: &#x27;posts&#x27;,
    select: {
      text: true,
      // select a specific field from group
      group: {
        number: true,
      },
      // select all fields from array
      array: true,
    }, // highlight-line
  })

  return posts
}

// Exclude mode
const getPosts = async (payload: Payload) =&gt; {
  const posts = await payload.find({
    collection: &#x27;posts&#x27;,
    // Select everything except for array and group.number
    select: {
      array: false,
      group: {
        number: false,
      },
    }, // highlight-line
  })

  return posts
}
</code></pre>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p><strong>Important:</strong> To perform querying with <code>select</code> efficiently, Payload
implements your <code>select</code> query on the database level. Because of that, your
<code>beforeRead</code> and <code>afterRead</code> hooks may not receive the full <code>doc</code>. To ensure
that some fields are always selected for your hooks / access control,
regardless of the <code>select</code> query you can use <code>forceSelect</code> collection config
property.</p></div>
<h2>REST API</h2>
<p>To specify select in the <a href="../rest-api/overview">REST API</a>, you can use the <code>select</code> parameter in your query:</p>
<pre><code class="language-ts">fetch(
  &#x27;https://localhost:3000/api/posts?select[color]=true&amp;select[group][number]=true&#x27;,
) // highlight-line
  .then((res) =&gt; res.json())
  .then((data) =&gt; console.log(data))
</code></pre>
<p>To understand the syntax, you need to understand that complex URL search strings are parsed into a JSON object. This one isn&#x27;t too bad, but more complex queries get unavoidably more difficult to write.</p>
<p>For this reason, we recommend to use the extremely helpful and ubiquitous <a href="https://www.npmjs.com/package/qs-esm"><code>qs-esm</code></a> package to parse your JSON / object-formatted queries into query strings:</p>
<pre><code class="language-ts">import { stringify } from &#x27;qs-esm&#x27;
import type { Where } from &#x27;payload&#x27;

const select: Where = {
  text: true,
  group: {
    number: true,
  },
  // This query could be much more complex
  // and QS would handle it beautifully
}

const getPosts = async () =&gt; {
  const stringifiedQuery = stringify(
    {
      select, // ensure that `qs` adds the `select` property, too!
    },
    { addQueryPrefix: true },
  )

  const response = await fetch(
    `http://localhost:3000/api/posts${stringifiedQuery}`,
  )
  // Continue to handle the response below...
}
</code></pre>
<div class="p-4 my-4 rounded-lg border bg-blue-50 border-blue-200 text-blue-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg><p><strong>Reminder:</strong> This is the same for <a href="../configuration/globals">Globals</a> using
the <code>/api/globals</code> endpoint.</p></div>
<h2>defaultPopulate collection config property</h2>
<p>The <code>defaultPopulate</code> property allows you specify which fields to select when populating the collection from another document.
This is especially useful for links where only the <code>slug</code> is needed instead of the entire document.</p>
<p>With this feature, you can dramatically reduce the amount of JSON that is populated from <a href="/docs/fields/relationship">Relationship</a> or <a href="/docs/fields/upload">Upload</a> fields.</p>
<p>For example, in your content model, you might have a <code>Link</code> field which links out to a different page. When you go to retrieve these links, you really only need the <code>slug</code> of the page.</p>
<p>Loading all of the page content, its related links, and everything else is going to be overkill and will bog down your Payload APIs. Instead, you can define the <code>defaultPopulate</code> property on your <code>Pages</code> collection, so that when Payload &quot;populates&quot; a related Page, it only selects the <code>slug</code> field and therefore returns significantly less JSON:</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

// The TSlug generic can be passed to have type safety for `defaultPopulate`.
// If avoided, the `defaultPopulate` type resolves to `SelectType`.
export const Pages: CollectionConfig&lt;&#x27;pages&#x27;&gt; = {
  slug: &#x27;pages&#x27;,
  // Specify `select`.
  defaultPopulate: {
    slug: true,
  },
  fields: [
    {
      name: &#x27;slug&#x27;,
      type: &#x27;text&#x27;,
      required: true,
    },
  ],
}
</code></pre>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p><strong>Important:</strong> When using <code>defaultPopulate</code> on a collection with
<a href="/docs/fields/upload">Uploads</a> enabled and you want to select the <code>url</code> field,
it is important to specify <code>filename: true</code> as well, otherwise Payload will
not be able to construct the correct file URL, instead returning <code>url: null</code>.</p></div>
<h2>populate</h2>
<p>Setting <code>defaultPopulate</code> will enforce that each time Payload performs a &quot;population&quot; of a related document, only the fields specified will be queried and returned. However, you can override <code>defaultPopulate</code> with the <code>populate</code> property in the Local and REST API:</p>
<p><strong>Local API:</strong></p>
<pre><code class="language-ts">import type { Payload } from &#x27;payload&#x27;

const getPosts = async (payload: Payload) =&gt; {
  const posts = await payload.find({
    collection: &#x27;posts&#x27;,
    populate: {
      // Select only `text` from populated docs in the &quot;pages&quot; collection
      // Now, no matter what the `defaultPopulate` is set to on the &quot;pages&quot; collection,
      // it will be overridden, and the `text` field will be returned instead.
      pages: {
        text: true,
      }, // highlight-line
    },
  })

  return posts
}
</code></pre>
<p><strong>REST API:</strong></p>
<pre><code class="language-ts">fetch(&#x27;https://localhost:3000/api/posts?populate[pages][text]=true&#x27;) // highlight-line
  .then((res) =&gt; res.json())
  .then((data) =&gt; console.log(data))
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Select","label":"Select","order":30,"desc":"Payload select determines which fields are selected to the result.","keywords":"query, documents, pagination, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    code: \"code\",\n    h2: \"h2\",\n    a: \"a\",\n    pre: \"pre\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"By default, Payload's APIs will return \", _jsx(_components.em, {\n        children: \"all fields\"\n      }), \" for a given collection or global. But, you may not need all of that data for all of your queries. Sometimes, you might want just a few fields from the response, which can speed up the Payload API and reduce the amount of JSON that is sent to you from the API.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is where Payload's \", _jsx(_components.code, {\n        children: \"select\"\n      }), \" feature comes in. Here, you can define exactly which fields you'd like to retrieve from the API.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Local API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To specify \", _jsx(_components.code, {\n        children: \"select\"\n      }), \" in the \", _jsx(_components.a, {\n        href: \"../local-api/overview\",\n        children: \"Local API\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"select\"\n      }), \" option in your query:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Payload } from 'payload'\\n\\n// Include mode\\nconst getPosts = async (payload: Payload) =\u003e {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    select: {\\n      text: true,\\n      // select a specific field from group\\n      group: {\\n        number: true,\\n      },\\n      // select all fields from array\\n      array: true,\\n    }, // highlight-line\\n  })\\n\\n  return posts\\n}\\n\\n// Exclude mode\\nconst getPosts = async (payload: Payload) =\u003e {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    // Select everything except for array and group.number\\n    select: {\\n      array: false,\\n      group: {\\n        number: false,\\n      },\\n    }, // highlight-line\\n  })\\n\\n  return posts\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Important:\"\n        }), \" To perform querying with \", _jsx(_components.code, {\n          children: \"select\"\n        }), \" efficiently, Payload\\nimplements your \", _jsx(_components.code, {\n          children: \"select\"\n        }), \" query on the database level. Because of that, your\\n\", _jsx(_components.code, {\n          children: \"beforeRead\"\n        }), \" and \", _jsx(_components.code, {\n          children: \"afterRead\"\n        }), \" hooks may not receive the full \", _jsx(_components.code, {\n          children: \"doc\"\n        }), \". To ensure\\nthat some fields are always selected for your hooks / access control,\\nregardless of the \", _jsx(_components.code, {\n          children: \"select\"\n        }), \" query you can use \", _jsx(_components.code, {\n          children: \"forceSelect\"\n        }), \" collection config\\nproperty.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"REST API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To specify select in the \", _jsx(_components.a, {\n        href: \"../rest-api/overview\",\n        children: \"REST API\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"select\"\n      }), \" parameter in your query:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"fetch(\\n  'https://localhost:3000/api/posts?select[color]=true\u0026select[group][number]=true',\\n) // highlight-line\\n  .then((res) =\u003e res.json())\\n  .then((data) =\u003e console.log(data))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To understand the syntax, you need to understand that complex URL search strings are parsed into a JSON object. This one isn't too bad, but more complex queries get unavoidably more difficult to write.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For this reason, we recommend to use the extremely helpful and ubiquitous \", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/qs-esm\",\n        children: _jsx(_components.code, {\n          children: \"qs-esm\"\n        })\n      }), \" package to parse your JSON / object-formatted queries into query strings:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { stringify } from 'qs-esm'\\nimport type { Where } from 'payload'\\n\\nconst select: Where = {\\n  text: true,\\n  group: {\\n    number: true,\\n  },\\n  // This query could be much more complex\\n  // and QS would handle it beautifully\\n}\\n\\nconst getPosts = async () =\u003e {\\n  const stringifiedQuery = stringify(\\n    {\\n      select, // ensure that `qs` adds the `select` property, too!\\n    },\\n    { addQueryPrefix: true },\\n  )\\n\\n  const response = await fetch(\\n    `http://localhost:3000/api/posts${stringifiedQuery}`,\\n  )\\n  // Continue to handle the response below...\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Reminder:\"\n        }), \" This is the same for \", _jsx(_components.a, {\n          href: \"../configuration/globals\",\n          children: \"Globals\"\n        }), \" using\\nthe \", _jsx(_components.code, {\n          children: \"/api/globals\"\n        }), \" endpoint.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"defaultPopulate collection config property\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"defaultPopulate\"\n      }), \" property allows you specify which fields to select when populating the collection from another document.\\nThis is especially useful for links where only the \", _jsx(_components.code, {\n        children: \"slug\"\n      }), \" is needed instead of the entire document.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With this feature, you can dramatically reduce the amount of JSON that is populated from \", _jsx(_components.a, {\n        href: \"/docs/fields/relationship\",\n        children: \"Relationship\"\n      }), \" or \", _jsx(_components.a, {\n        href: \"/docs/fields/upload\",\n        children: \"Upload\"\n      }), \" fields.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, in your content model, you might have a \", _jsx(_components.code, {\n        children: \"Link\"\n      }), \" field which links out to a different page. When you go to retrieve these links, you really only need the \", _jsx(_components.code, {\n        children: \"slug\"\n      }), \" of the page.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Loading all of the page content, its related links, and everything else is going to be overkill and will bog down your Payload APIs. Instead, you can define the \", _jsx(_components.code, {\n        children: \"defaultPopulate\"\n      }), \" property on your \", _jsx(_components.code, {\n        children: \"Pages\"\n      }), \" collection, so that when Payload \\\"populates\\\" a related Page, it only selects the \", _jsx(_components.code, {\n        children: \"slug\"\n      }), \" field and therefore returns significantly less JSON:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\n// The TSlug generic can be passed to have type safety for `defaultPopulate`.\\n// If avoided, the `defaultPopulate` type resolves to `SelectType`.\\nexport const Pages: CollectionConfig\u003c'pages'\u003e = {\\n  slug: 'pages',\\n  // Specify `select`.\\n  defaultPopulate: {\\n    slug: true,\\n  },\\n  fields: [\\n    {\\n      name: 'slug',\\n      type: 'text',\\n      required: true,\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Important:\"\n        }), \" When using \", _jsx(_components.code, {\n          children: \"defaultPopulate\"\n        }), \" on a collection with\\n\", _jsx(_components.a, {\n          href: \"/docs/fields/upload\",\n          children: \"Uploads\"\n        }), \" enabled and you want to select the \", _jsx(_components.code, {\n          children: \"url\"\n        }), \" field,\\nit is important to specify \", _jsx(_components.code, {\n          children: \"filename: true\"\n        }), \" as well, otherwise Payload will\\nnot be able to construct the correct file URL, instead returning \", _jsx(_components.code, {\n          children: \"url: null\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"populate\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Setting \", _jsx(_components.code, {\n        children: \"defaultPopulate\"\n      }), \" will enforce that each time Payload performs a \\\"population\\\" of a related document, only the fields specified will be queried and returned. However, you can override \", _jsx(_components.code, {\n        children: \"defaultPopulate\"\n      }), \" with the \", _jsx(_components.code, {\n        children: \"populate\"\n      }), \" property in the Local and REST API:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Local API:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Payload } from 'payload'\\n\\nconst getPosts = async (payload: Payload) =\u003e {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    populate: {\\n      // Select only `text` from populated docs in the \\\"pages\\\" collection\\n      // Now, no matter what the `defaultPopulate` is set to on the \\\"pages\\\" collection,\\n      // it will be overridden, and the `text` field will be returned instead.\\n      pages: {\\n        text: true,\\n      }, // highlight-line\\n    },\\n  })\\n\\n  return posts\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"REST API:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"fetch('https://localhost:3000/api/posts?populate[pages][text]=true') // highlight-line\\n  .then((res) =\u003e res.json())\\n  .then((data) =\u003e console.log(data))\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["queries","select"]},"buildId":"pbayt_BRhSN28J-gcoKlf","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>