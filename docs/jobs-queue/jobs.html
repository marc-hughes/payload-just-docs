<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Jobs</h1><p class="text-xl text-gray-600 mb-8">A Job is a set of work that is offloaded from your APIs and will be processed at a later date.</p><div class="prose prose-lg max-w-none"><p>Now that we have covered Tasks and Workflows, we can tie them together with a concept called a Job.</p>
<div class="p-4 my-4 rounded-lg border undefined"><p>Whereas you define Workflows and Tasks, which control your business logic, a
<strong>Job</strong> is an individual instance of either a Task or a Workflow which
contains many tasks.</p></div>
<p>For example, let&#x27;s say we have a Workflow or Task that describes the logic to sync information from Payload to a third-party system. This is how you&#x27;d declare how to sync that info, but it wouldn&#x27;t do anything on its own. In order to run that task or workflow, you&#x27;d create a Job that references the corresponding Task or Workflow.</p>
<p>Jobs are stored in the Payload database in the <code>payload-jobs</code> collection, and you can decide to keep a running list of all jobs, or configure Payload to delete the job when it has been successfully executed.</p>
<h4>Queuing a new job</h4>
<p>In order to queue a job, you can use the <code>payload.jobs.queue</code> function.</p>
<p>Here&#x27;s how you&#x27;d queue a new Job, which will run a <code>createPostAndUpdate</code> workflow:</p>
<pre><code class="language-ts">const createdJob = await payload.jobs.queue({
  // Pass the name of the workflow
  workflow: &#x27;createPostAndUpdate&#x27;,
  // The input type will be automatically typed
  // according to the input you&#x27;ve defined for this workflow
  input: {
    title: &#x27;my title&#x27;,
  },
})
</code></pre>
<p>In addition to being able to queue new Jobs based on Workflows, you can also queue a job for a single Task:</p>
<pre><code class="language-ts">const createdJob = await payload.jobs.queue({
  task: &#x27;createPost&#x27;,
  input: {
    title: &#x27;my title&#x27;,
  },
})
</code></pre>
<h4>Cancelling Jobs</h4>
<p>Payload allows you to cancel jobs that are either queued or currently running. When cancelling a running job, the current task will finish executing, but no subsequent tasks will run. This happens because the job checks its cancellation status between tasks.</p>
<h5>Cancel a Single Job</h5>
<p>To cancel a specific job, use the <code>payload.jobs.cancelByID</code> method with the job&#x27;s ID:</p>
<pre><code class="language-ts">await payload.jobs.cancelByID({
  id: createdJob.id,
})
</code></pre>
<h5>Cancel Multiple Jobs</h5>
<p>To cancel multiple jobs at once, use the <code>payload.jobs.cancel</code> method with a <code>Where</code> query:</p>
<pre><code class="language-ts">await payload.jobs.cancel({
  where: {
    workflowSlug: {
      equals: &#x27;createPost&#x27;,
    },
  },
})
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Jobs","label":"Jobs","order":40,"desc":"A Job is a set of work that is offloaded from your APIs and will be processed at a later date.","keywords":"jobs queue, application framework, typescript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    h4: \"h4\",\n    pre: \"pre\",\n    h5: \"h5\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Now that we have covered Tasks and Workflows, we can tie them together with a concept called a Job.\"\n    }), \"\\n\", _jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"Whereas you define Workflows and Tasks, which control your business logic, a\\n\", _jsx(_components.strong, {\n          children: \"Job\"\n        }), \" is an individual instance of either a Task or a Workflow which\\ncontains many tasks.\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, let's say we have a Workflow or Task that describes the logic to sync information from Payload to a third-party system. This is how you'd declare how to sync that info, but it wouldn't do anything on its own. In order to run that task or workflow, you'd create a Job that references the corresponding Task or Workflow.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Jobs are stored in the Payload database in the \", _jsx(_components.code, {\n        children: \"payload-jobs\"\n      }), \" collection, and you can decide to keep a running list of all jobs, or configure Payload to delete the job when it has been successfully executed.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Queuing a new job\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to queue a job, you can use the \", _jsx(_components.code, {\n        children: \"payload.jobs.queue\"\n      }), \" function.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here's how you'd queue a new Job, which will run a \", _jsx(_components.code, {\n        children: \"createPostAndUpdate\"\n      }), \" workflow:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const createdJob = await payload.jobs.queue({\\n  // Pass the name of the workflow\\n  workflow: 'createPostAndUpdate',\\n  // The input type will be automatically typed\\n  // according to the input you've defined for this workflow\\n  input: {\\n    title: 'my title',\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In addition to being able to queue new Jobs based on Workflows, you can also queue a job for a single Task:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const createdJob = await payload.jobs.queue({\\n  task: 'createPost',\\n  input: {\\n    title: 'my title',\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Cancelling Jobs\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Payload allows you to cancel jobs that are either queued or currently running. When cancelling a running job, the current task will finish executing, but no subsequent tasks will run. This happens because the job checks its cancellation status between tasks.\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Cancel a Single Job\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To cancel a specific job, use the \", _jsx(_components.code, {\n        children: \"payload.jobs.cancelByID\"\n      }), \" method with the job's ID:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"await payload.jobs.cancelByID({\\n  id: createdJob.id,\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Cancel Multiple Jobs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To cancel multiple jobs at once, use the \", _jsx(_components.code, {\n        children: \"payload.jobs.cancel\"\n      }), \" method with a \", _jsx(_components.code, {\n        children: \"Where\"\n      }), \" query:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"await payload.jobs.cancel({\\n  where: {\\n    workflowSlug: {\\n      equals: 'createPost',\\n    },\\n  },\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["jobs-queue","jobs"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>