<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Jobs Queue</h1><p class="text-xl text-gray-600 mb-8">Payload provides all you need to run job queues, which are helpful to offload long-running processes into separate workers.</p><div class="prose prose-lg max-w-none"><p>Payload&#x27;s Jobs Queue gives you a simple, yet powerful way to offload large or future tasks to separate compute resources which is a very powerful feature of many application frameworks.</p>
<h3>Example use cases</h3>
<p><strong>Non-blocking workloads</strong></p>
<p>You might need to perform some complex, slow-running logic in a Payload <a href="/payload-just-docs/docs/hooks/overview">Hook</a> but you don&#x27;t want that hook to &quot;block&quot; or slow down the response returned from the Payload API. Instead of running this logic directly in a hook, which would block your API response from returning until the expensive work is completed, you can queue a new Job and let it run at a later date.</p>
<p>Examples:</p>
<ul>
<li>Create vector embeddings from your documents, and keep them in sync as your documents change</li>
<li>Send data to a third-party API on document change</li>
<li>Trigger emails based on customer actions</li>
</ul>
<p><strong>Scheduled actions</strong></p>
<p>If you need to schedule an action to be run or processed at a certain date in the future, you can queue a job with the <code>waitUntil</code> property set. This will make it so the job is not &quot;picked up&quot; until that <code>waitUntil</code> date has passed.</p>
<p>Examples:</p>
<ul>
<li>Process scheduled posts, where the scheduled date is at a time set in the future</li>
<li>Unpublish posts at a given time</li>
<li>Send a reminder email to a customer after X days of signing up for a trial</li>
</ul>
<p><strong>Periodic sync or similar scheduled action</strong></p>
<p>Some applications may need to perform a regularly scheduled operation of some type. Jobs are perfect for this because you can execute their logic using <code>cron</code>, scheduled nightly, every twelve hours, or some similar time period.</p>
<p>Examples:</p>
<ul>
<li>You&#x27;d like to send emails to all customers on a regular, scheduled basis</li>
<li>Periodically trigger a rebuild of your frontend at night</li>
<li>Sync resources to or from a third-party API during non-peak times</li>
</ul>
<p><strong>Offloading complex operations</strong></p>
<p>You may run into the need to perform computationally expensive functions which might slow down your main Payload API server(s). The Jobs Queue allows you to offload these tasks to a separate compute resource rather than slowing down the server(s) that run your Payload APIs. With Payload Task definitions, you can even keep large dependencies out of your main Next.js bundle by dynamically importing them only when they are used. This keeps your Next.js + Payload compilation fast and ensures large dependencies do not get bundled into your Payload production build.</p>
<p>Examples:</p>
<ul>
<li>You need to create (and then keep in sync) vector embeddings of your documents as they change, but you use an open source model to generate embeddings</li>
<li>You have a PDF generator that needs to dynamically build and send PDF versions of documents to customers</li>
<li>You need to use a headless browser to perform some type of logic</li>
<li>You need to perform a series of actions, each of which depends on a prior action and should be run in as &quot;durable&quot; of a fashion as possible</li>
</ul>
<h3>How it works</h3>
<p>There are a few concepts that you should become familiarized with before using Payload&#x27;s Jobs Queue. We recommend learning what each of these does in order to fully understand how to leverage the power of Payload&#x27;s Jobs Queue.</p>
<ol>
<li><a href="/payload-just-docs/docs/jobs-queue/tasks">Tasks</a></li>
<li><a href="/payload-just-docs/docs/jobs-queue/workflows">Workflows</a></li>
<li><a href="/payload-just-docs/docs/jobs-queue/jobs">Jobs</a></li>
<li><a href="/payload-just-docs/docs/jobs-queue/queues">Queues</a></li>
</ol>
<p>All of these pieces work together in order to allow you to offload long-running, expensive, or future scheduled work from your main APIs.</p>
<p>Here&#x27;s a quick overview:</p>
<ul>
<li>A Task is a specific function that performs business logic</li>
<li>Workflows are groupings of specific tasks which should be run in-order, and can be retried from a specific point of failure</li>
<li>A Job is an instance of a single task or workflow which will be executed</li>
<li>A Queue is a way to segment your jobs into different &quot;groups&quot; - for example, some to run nightly, and others to run every 10 minutes</li>
</ul></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Jobs Queue","label":"Overview","order":10,"desc":"Payload provides all you need to run job queues, which are helpful to offload long-running processes into separate workers.","keywords":"jobs queue, application framework, typescript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    strong: \"strong\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Payload's Jobs Queue gives you a simple, yet powerful way to offload large or future tasks to separate compute resources which is a very powerful feature of many application frameworks.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example use cases\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Non-blocking workloads\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You might need to perform some complex, slow-running logic in a Payload \", _jsx(_components.a, {\n        href: \"/docs/hooks/overview\",\n        children: \"Hook\"\n      }), \" but you don't want that hook to \\\"block\\\" or slow down the response returned from the Payload API. Instead of running this logic directly in a hook, which would block your API response from returning until the expensive work is completed, you can queue a new Job and let it run at a later date.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Examples:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Create vector embeddings from your documents, and keep them in sync as your documents change\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Send data to a third-party API on document change\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Trigger emails based on customer actions\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Scheduled actions\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you need to schedule an action to be run or processed at a certain date in the future, you can queue a job with the \", _jsx(_components.code, {\n        children: \"waitUntil\"\n      }), \" property set. This will make it so the job is not \\\"picked up\\\" until that \", _jsx(_components.code, {\n        children: \"waitUntil\"\n      }), \" date has passed.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Examples:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Process scheduled posts, where the scheduled date is at a time set in the future\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Unpublish posts at a given time\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Send a reminder email to a customer after X days of signing up for a trial\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Periodic sync or similar scheduled action\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Some applications may need to perform a regularly scheduled operation of some type. Jobs are perfect for this because you can execute their logic using \", _jsx(_components.code, {\n        children: \"cron\"\n      }), \", scheduled nightly, every twelve hours, or some similar time period.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Examples:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You'd like to send emails to all customers on a regular, scheduled basis\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Periodically trigger a rebuild of your frontend at night\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Sync resources to or from a third-party API during non-peak times\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Offloading complex operations\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You may run into the need to perform computationally expensive functions which might slow down your main Payload API server(s). The Jobs Queue allows you to offload these tasks to a separate compute resource rather than slowing down the server(s) that run your Payload APIs. With Payload Task definitions, you can even keep large dependencies out of your main Next.js bundle by dynamically importing them only when they are used. This keeps your Next.js + Payload compilation fast and ensures large dependencies do not get bundled into your Payload production build.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Examples:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You need to create (and then keep in sync) vector embeddings of your documents as they change, but you use an open source model to generate embeddings\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"You have a PDF generator that needs to dynamically build and send PDF versions of documents to customers\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"You need to use a headless browser to perform some type of logic\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"You need to perform a series of actions, each of which depends on a prior action and should be run in as \\\"durable\\\" of a fashion as possible\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"How it works\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are a few concepts that you should become familiarized with before using Payload's Jobs Queue. We recommend learning what each of these does in order to fully understand how to leverage the power of Payload's Jobs Queue.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/jobs-queue/tasks\",\n          children: \"Tasks\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/jobs-queue/workflows\",\n          children: \"Workflows\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/jobs-queue/jobs\",\n          children: \"Jobs\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/jobs-queue/queues\",\n          children: \"Queues\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All of these pieces work together in order to allow you to offload long-running, expensive, or future scheduled work from your main APIs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here's a quick overview:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"A Task is a specific function that performs business logic\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Workflows are groupings of specific tasks which should be run in-order, and can be retried from a specific point of failure\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A Job is an instance of a single task or workflow which will be executed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A Queue is a way to segment your jobs into different \\\"groups\\\" - for example, some to run nightly, and others to run every 10 minutes\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["jobs-queue","overview"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>