<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Workflows</h1><p class="text-xl text-gray-600 mb-8">A Task is a distinct function declaration that can be run within Payload&#x27;s Jobs Queue.</p><div class="prose prose-lg max-w-none"><div class="p-4 my-4 rounded-lg border undefined"><p>A <strong>&quot;Workflow&quot;</strong> is an optional way to <em>combine multiple tasks together</em> in a
way that can be gracefully retried from the point of failure.</p></div>
<p>They&#x27;re most helpful when you have multiple tasks in a row, and you want to configure each task to be able to be retried if they fail.</p>
<p>If a task within a workflow fails, the Workflow will automatically &quot;pick back up&quot; on the task where it failed and <strong>not re-execute any prior tasks that have already been executed</strong>.</p>
<h4>Defining a workflow</h4>
<p>The most important aspect of a Workflow is the <code>handler</code>, where you can declare when and how the tasks should run by simply calling the <code>runTask</code> function. If any task within the workflow, fails, the entire <code>handler</code> function will re-run.</p>
<p>However, importantly, tasks that have successfully been completed will simply re-return the cached and saved output without running again. The Workflow will pick back up where it failed and only task from the failure point onward will be re-executed.</p>
<p>To define a JS-based workflow, simply add a workflow to the <code>jobs.workflows</code> array in your Payload config. A workflow consists of the following fields:</p>
<div class="overflow-x-auto my-8"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr class="even:bg-gray-50"><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Option</th><th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>slug</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Define a slug-based name for this workflow. This slug needs to be unique among both tasks and workflows.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>handler</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">The function that should be responsible for running the workflow. You can either pass a string-based path to the workflow function file, or workflow job function itself. If you are using large dependencies within your workflow, you might prefer to pass the string path because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature that may require a sophisticated build pipeline in order to work.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>inputSchema</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Define the input field schema - Payload will generate a type for this schema.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>interfaceName</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">You can use interfaceName to change the name of the interface that is generated for this workflow. By default, this is &quot;Workflow&quot; + the capitalized workflow slug.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>label</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Define a human-friendly label for this workflow.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>queue</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">Optionally, define the queue name that this workflow should be tied to. Defaults to &quot;default&quot;.</td></tr><tr class="even:bg-gray-50"><td class="px-6 py-4 whitespace-normal text-sm text-gray-500"><code>retries</code></td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">You can define <code>retries</code> on the workflow level, which will enforce that the workflow can only fail up to that number of retries. If a task does not have retries specified, it will inherit the retry count as specified on the workflow. You can specify <code>0</code> as <code>workflow</code> retries, which will disregard all <code>task</code> retry specifications and fail the entire workflow on any task failure. You can leave <code>workflow</code> retries as undefined, in which case, the workflow will respect what each task dictates as their own retry count. By default this is undefined, meaning workflows retries are defined by their tasks</td></tr></tbody></table></div>
<p>Example:</p>
<pre><code class="language-ts">export default buildConfig({
  // ...
  jobs: {
    tasks: [
      // ...
    ]
    workflows: [
      {
        slug: &#x27;createPostAndUpdate&#x27;,

        // The arguments that the workflow will accept
        inputSchema: [
          {
            name: &#x27;title&#x27;,
            type: &#x27;text&#x27;,
            required: true,
          },
        ],

        // The handler that defines the &quot;control flow&quot; of the workflow
        // Notice how it uses the `tasks` argument to execute your predefined tasks.
        // These are strongly typed!
        handler: async ({ job, tasks }) =&gt; {

          // This workflow first runs a task called `createPost`.

          // You need to define a unique ID for this task invocation
          // that will always be the same if this workflow fails
          // and is re-executed in the future. Here, we hard-code it to &#x27;1&#x27;
          const output = await tasks.createPost(&#x27;1&#x27;, {
            input: {
              title: job.input.title,
            },
          })

          // Once the prior task completes, it will run a task
          // called `updatePost`
          await tasks.updatePost(&#x27;2&#x27;, {
            input: {
              post: job.taskStatus.createPost[&#x27;1&#x27;].output.postID, // or output.postID
              title: job.input.title + &#x27;2&#x27;,
            },
          })
        },
      } as WorkflowConfig&lt;&#x27;updatePost&#x27;&gt;
    ]
  }
})
</code></pre>
<h4>Running tasks inline</h4>
<p>In the above example, our workflow was executing tasks that we already had defined in our Payload config. But, you can also run tasks without predefining them.</p>
<p>To do this, you can use the <code>inlineTask</code> function.</p>
<p>The drawbacks of this approach are that tasks cannot be re-used across workflows as easily, and the <strong>task data stored in the job</strong> will not be typed. In the following example, the inline task data will be stored on the job under <code>job.taskStatus.inline[&#x27;2&#x27;]</code> but completely untyped, as types for dynamic tasks like these cannot be generated beforehand.</p>
<p>Example:</p>
<pre><code class="language-ts">export default buildConfig({
  // ...
  jobs: {
    tasks: [
      // ...
    ]
    workflows: [
      {
        slug: &#x27;createPostAndUpdate&#x27;,
        inputSchema: [
          {
            name: &#x27;title&#x27;,
            type: &#x27;text&#x27;,
            required: true,
          },
        ],
        handler: async ({ job, tasks, inlineTask }) =&gt; {
          // Here, we run a predefined task.
          // The `createPost` handler arguments and return type
          // are both strongly typed
          const output = await tasks.createPost(&#x27;1&#x27;, {
            input: {
              title: job.input.title,
            },
          })

          // Here, this task is not defined in the Payload config
          // and is &quot;inline&quot;. Its output will be stored on the Job in the database
          // however its arguments will be untyped.
          const { newPost } = await inlineTask(&#x27;2&#x27;, {
            task: async ({ req }) =&gt; {
              const newPost = await req.payload.update({
                collection: &#x27;post&#x27;,
                id: &#x27;2&#x27;,
                req,
                retries: 3,
                data: {
                  title: &#x27;updated!&#x27;,
                },
              })
              return {
                output: {
                  newPost
                },
              }
            },
          })
        },
      } as WorkflowConfig&lt;&#x27;updatePost&#x27;&gt;
    ]
  }
})
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Workflows","label":"Workflows","order":30,"desc":"A Task is a distinct function declaration that can be run within Payload's Jobs Queue.","keywords":"jobs queue, application framework, typescript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    em: \"em\",\n    h4: \"h4\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"\\\"Workflow\\\"\"\n        }), \" is an optional way to \", _jsx(_components.em, {\n          children: \"combine multiple tasks together\"\n        }), \" in a\\nway that can be gracefully retried from the point of failure.\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"They're most helpful when you have multiple tasks in a row, and you want to configure each task to be able to be retried if they fail.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If a task within a workflow fails, the Workflow will automatically \\\"pick back up\\\" on the task where it failed and \", _jsx(_components.strong, {\n        children: \"not re-execute any prior tasks that have already been executed\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Defining a workflow\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The most important aspect of a Workflow is the \", _jsx(_components.code, {\n        children: \"handler\"\n      }), \", where you can declare when and how the tasks should run by simply calling the \", _jsx(_components.code, {\n        children: \"runTask\"\n      }), \" function. If any task within the workflow, fails, the entire \", _jsx(_components.code, {\n        children: \"handler\"\n      }), \" function will re-run.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"However, importantly, tasks that have successfully been completed will simply re-return the cached and saved output without running again. The Workflow will pick back up where it failed and only task from the failure point onward will be re-executed.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To define a JS-based workflow, simply add a workflow to the \", _jsx(_components.code, {\n        children: \"jobs.workflows\"\n      }), \" array in your Payload config. A workflow consists of the following fields:\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Option\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"slug\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Define a slug-based name for this workflow. This slug needs to be unique among both tasks and workflows.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"handler\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The function that should be responsible for running the workflow. You can either pass a string-based path to the workflow function file, or workflow job function itself. If you are using large dependencies within your workflow, you might prefer to pass the string path because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature that may require a sophisticated build pipeline in order to work.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"inputSchema\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Define the input field schema - Payload will generate a type for this schema.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"interfaceName\"\n            })\n          }), _jsx(_components.td, {\n            children: \"You can use interfaceName to change the name of the interface that is generated for this workflow. By default, this is \\\"Workflow\\\" + the capitalized workflow slug.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"label\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Define a human-friendly label for this workflow.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"queue\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Optionally, define the queue name that this workflow should be tied to. Defaults to \\\"default\\\".\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"retries\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"You can define \", _jsx(_components.code, {\n              children: \"retries\"\n            }), \" on the workflow level, which will enforce that the workflow can only fail up to that number of retries. If a task does not have retries specified, it will inherit the retry count as specified on the workflow. You can specify \", _jsx(_components.code, {\n              children: \"0\"\n            }), \" as \", _jsx(_components.code, {\n              children: \"workflow\"\n            }), \" retries, which will disregard all \", _jsx(_components.code, {\n              children: \"task\"\n            }), \" retry specifications and fail the entire workflow on any task failure. You can leave \", _jsx(_components.code, {\n              children: \"workflow\"\n            }), \" retries as undefined, in which case, the workflow will respect what each task dictates as their own retry count. By default this is undefined, meaning workflows retries are defined by their tasks\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // ...\\n  jobs: {\\n    tasks: [\\n      // ...\\n    ]\\n    workflows: [\\n      {\\n        slug: 'createPostAndUpdate',\\n\\n        // The arguments that the workflow will accept\\n        inputSchema: [\\n          {\\n            name: 'title',\\n            type: 'text',\\n            required: true,\\n          },\\n        ],\\n\\n        // The handler that defines the \\\"control flow\\\" of the workflow\\n        // Notice how it uses the `tasks` argument to execute your predefined tasks.\\n        // These are strongly typed!\\n        handler: async ({ job, tasks }) =\u003e {\\n\\n          // This workflow first runs a task called `createPost`.\\n\\n          // You need to define a unique ID for this task invocation\\n          // that will always be the same if this workflow fails\\n          // and is re-executed in the future. Here, we hard-code it to '1'\\n          const output = await tasks.createPost('1', {\\n            input: {\\n              title: job.input.title,\\n            },\\n          })\\n\\n          // Once the prior task completes, it will run a task\\n          // called `updatePost`\\n          await tasks.updatePost('2', {\\n            input: {\\n              post: job.taskStatus.createPost['1'].output.postID, // or output.postID\\n              title: job.input.title + '2',\\n            },\\n          })\\n        },\\n      } as WorkflowConfig\u003c'updatePost'\u003e\\n    ]\\n  }\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Running tasks inline\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the above example, our workflow was executing tasks that we already had defined in our Payload config. But, you can also run tasks without predefining them.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To do this, you can use the \", _jsx(_components.code, {\n        children: \"inlineTask\"\n      }), \" function.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The drawbacks of this approach are that tasks cannot be re-used across workflows as easily, and the \", _jsx(_components.strong, {\n        children: \"task data stored in the job\"\n      }), \" will not be typed. In the following example, the inline task data will be stored on the job under \", _jsx(_components.code, {\n        children: \"job.taskStatus.inline['2']\"\n      }), \" but completely untyped, as types for dynamic tasks like these cannot be generated beforehand.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // ...\\n  jobs: {\\n    tasks: [\\n      // ...\\n    ]\\n    workflows: [\\n      {\\n        slug: 'createPostAndUpdate',\\n        inputSchema: [\\n          {\\n            name: 'title',\\n            type: 'text',\\n            required: true,\\n          },\\n        ],\\n        handler: async ({ job, tasks, inlineTask }) =\u003e {\\n          // Here, we run a predefined task.\\n          // The `createPost` handler arguments and return type\\n          // are both strongly typed\\n          const output = await tasks.createPost('1', {\\n            input: {\\n              title: job.input.title,\\n            },\\n          })\\n\\n          // Here, this task is not defined in the Payload config\\n          // and is \\\"inline\\\". Its output will be stored on the Job in the database\\n          // however its arguments will be untyped.\\n          const { newPost } = await inlineTask('2', {\\n            task: async ({ req }) =\u003e {\\n              const newPost = await req.payload.update({\\n                collection: 'post',\\n                id: '2',\\n                req,\\n                retries: 3,\\n                data: {\\n                  title: 'updated!',\\n                },\\n              })\\n              return {\\n                output: {\\n                  newPost\\n                },\\n              }\\n            },\\n          })\\n        },\\n      } as WorkflowConfig\u003c'updatePost'\u003e\\n    ]\\n  }\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["jobs-queue","workflows"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>