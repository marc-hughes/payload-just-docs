<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-fd8027ecb5121007.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-04104d75f6814829.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/docs/%5B...slug%5D-e023289636109d90.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/rEpVRygLyV6yJ0i_Ohw0C/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Cookie Strategy</h1><p class="text-xl text-gray-600 mb-8">Enable HTTP Cookie based authentication to interface with Payload.</p><div class="prose prose-lg max-w-none"><p>Payload offers the ability to <a href="./overview">Authenticate</a> via HTTP-only cookies. These can be read from the responses of <code>login</code>, <code>logout</code>, <code>refresh</code>, and <code>me</code> auth operations.</p>
<div class="p-4 my-4 rounded-lg border bg-green-50 border-green-200 text-green-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg><p><strong>Tip:</strong> You can access the logged-in user from within <a href="../access-control/overview">Access
Control</a> and <a href="../hooks/overview">Hooks</a> through
the <code>req.user</code> argument. <a href="./token-data">More details</a>.</p></div>
<h3>Automatic browser inclusion</h3>
<p>Modern browsers automatically include <code>http-only</code> cookies when making requests directly to URLsâ€”meaning that if you are running your API on <code>https://example.com</code>, and you have logged in and visit <code>https://example.com/test-page</code>, your browser will automatically include the Payload authentication cookie for you.</p>
<h3>HTTP Authentication</h3>
<p>However, if you use <code>fetch</code> or similar APIs to retrieve Payload resources from its REST or GraphQL API, you must specify to include credentials (cookies).</p>
<p>Fetch example, including credentials:</p>
<pre><code class="language-ts">const response = await fetch(&#x27;http://localhost:3000/api/pages&#x27;, {
  credentials: &#x27;include&#x27;,
})

const pages = await response.json()
</code></pre>
<p>For more about including cookies in requests from your app to your Payload API, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Sending_a_request_with_credentials_included">read the MDN docs</a>.</p>
<div class="p-4 my-4 rounded-lg border bg-green-50 border-green-200 text-green-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg><p><strong>Tip:</strong> To make sure you have a Payload cookie set properly in your browser
after logging in, you can use the browsers Developer Tools &gt; Application &gt;
Cookies &gt; [your-domain-here]. The Developer tools will still show HTTP-only
cookies.</p></div>
<h3>CSRF Attacks</h3>
<p>CSRF (cross-site request forgery) attacks are common and dangerous. By using an HTTP-only cookie, Payload removes many XSS vulnerabilities, however, CSRF attacks can still be possible.</p>
<p>For example, let&#x27;s say you have a popular app <code>https://payload-finances.com</code> that allows users to manage finances, send and receive money. As Payload is using HTTP-only cookies, that means that browsers automatically will include cookies when sending requests to your domain - <strong>no matter what page created the request</strong>.</p>
<p>So, if a user of <code>https://payload-finances.com</code> is logged in and is browsing around on the internet, they might stumble onto a page with malicious intent. Let&#x27;s look at an example:</p>
<pre><code class="language-ts">// malicious-intent.com
// makes an authenticated request as on your behalf

const maliciousRequest = await fetch(`https://payload-finances.com/api/me`, {
  credentials: &#x27;include&#x27;,
}).then((res) =&gt; await res.json())
</code></pre>
<p>In this scenario, if your cookie was still valid, malicious-intent.com would be able to make requests like the one above on your behalf. This is a CSRF attack.</p>
<h3>CSRF Prevention</h3>
<p>Define domains that your trust and are willing to accept Payload HTTP-only cookie based requests from. Use the <code>csrf</code> option on the base Payload Config to do this:</p>
<pre><code class="language-ts">// payload.config.ts

import { buildConfig } from &#x27;payload&#x27;

const config = buildConfig({
  serverURL: &#x27;https://my-payload-instance.com&#x27;,
  // highlight-start
  csrf: [
    // whitelist of domains to allow cookie auth from
    &#x27;https://your-frontend-app.com&#x27;,
    &#x27;https://your-other-frontend-app.com&#x27;,
    // `config.serverURL` is added by default if defined
  ],
  // highlight-end
  collections: [
    // collections here
  ],
})

export default config
</code></pre>
<h4>Cross domain authentication</h4>
<p>If your frontend is on a different domain than your Payload API then you will not be able to use HTTP-only cookies for authentication by default as they will be considered third-party cookies by the browser.
There are a few strategies to get around this:</p>
<h5>1. Use subdomains</h5>
<p>Cookies can cross subdomains without being considered third party cookies, for example if your API is at api.example.com then you can authenticate from example.com.</p>
<h5>2. Configure cookies</h5>
<p>If option 1 isn&#x27;t possible, then you can get around this limitation by <a href="./overview#config-options">configuring your cookies</a> on your authentication collection to achieve the following setup:</p>
<pre><code>SameSite: None // allows the cookie to cross domains
Secure: true // ensures its sent over HTTPS only
HttpOnly: true // ensures its not accessible via client side JavaScript
</code></pre>
<p>Configuration example:</p>
<pre><code class="language-ts">{
  slug: &#x27;users&#x27;,
  auth: {
    cookies: {
      sameSite: &#x27;None&#x27;,
      secure: true,
    }
  },
  fields: [
    // your auth fields here
  ]
},
</code></pre>
<p>If you&#x27;re configuring <a href="../production/preventing-abuse#cross-origin-resource-sharing-cors">cors</a> in your Payload config, you won&#x27;t be able to use a wildcard anymore, you&#x27;ll need to specify the list of allowed domains.</p>
<div class="p-4 my-4 rounded-lg border bg-green-50 border-green-200 text-green-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg><p><strong>Good to know:</strong> Setting up <code>secure: true</code> will not work if you&#x27;re developing
on <code>http://localhost</code> or any non-https domain. For local development you
should conditionally set this to <code>false</code> based on the environment.</p></div></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Cookie Strategy","label":"Cookie Strategy","order":40,"desc":"Enable HTTP Cookie based authentication to interface with Payload.","keywords":"authentication, config, configuration, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\",\n    h4: \"h4\",\n    h5: \"h5\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Payload offers the ability to \", _jsx(_components.a, {\n        href: \"./overview\",\n        children: \"Authenticate\"\n      }), \" via HTTP-only cookies. These can be read from the responses of \", _jsx(_components.code, {\n        children: \"login\"\n      }), \", \", _jsx(_components.code, {\n        children: \"logout\"\n      }), \", \", _jsx(_components.code, {\n        children: \"refresh\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"me\"\n      }), \" auth operations.\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" You can access the logged-in user from within \", _jsx(_components.a, {\n          href: \"../access-control/overview\",\n          children: \"Access\\nControl\"\n        }), \" and \", _jsx(_components.a, {\n          href: \"../hooks/overview\",\n          children: \"Hooks\"\n        }), \" through\\nthe \", _jsx(_components.code, {\n          children: \"req.user\"\n        }), \" argument. \", _jsx(_components.a, {\n          href: \"./token-data\",\n          children: \"More details\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Automatic browser inclusion\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Modern browsers automatically include \", _jsx(_components.code, {\n        children: \"http-only\"\n      }), \" cookies when making requests directly to URLsâ€”meaning that if you are running your API on \", _jsx(_components.code, {\n        children: \"https://example.com\"\n      }), \", and you have logged in and visit \", _jsx(_components.code, {\n        children: \"https://example.com/test-page\"\n      }), \", your browser will automatically include the Payload authentication cookie for you.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"HTTP Authentication\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, if you use \", _jsx(_components.code, {\n        children: \"fetch\"\n      }), \" or similar APIs to retrieve Payload resources from its REST or GraphQL API, you must specify to include credentials (cookies).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fetch example, including credentials:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const response = await fetch('http://localhost:3000/api/pages', {\\n  credentials: 'include',\\n})\\n\\nconst pages = await response.json()\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For more about including cookies in requests from your app to your Payload API, \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Sending_a_request_with_credentials_included\",\n        children: \"read the MDN docs\"\n      }), \".\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" To make sure you have a Payload cookie set properly in your browser\\nafter logging in, you can use the browsers Developer Tools \u003e Application \u003e\\nCookies \u003e [your-domain-here]. The Developer tools will still show HTTP-only\\ncookies.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CSRF Attacks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CSRF (cross-site request forgery) attacks are common and dangerous. By using an HTTP-only cookie, Payload removes many XSS vulnerabilities, however, CSRF attacks can still be possible.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, let's say you have a popular app \", _jsx(_components.code, {\n        children: \"https://payload-finances.com\"\n      }), \" that allows users to manage finances, send and receive money. As Payload is using HTTP-only cookies, that means that browsers automatically will include cookies when sending requests to your domain - \", _jsx(_components.strong, {\n        children: \"no matter what page created the request\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, if a user of \", _jsx(_components.code, {\n        children: \"https://payload-finances.com\"\n      }), \" is logged in and is browsing around on the internet, they might stumble onto a page with malicious intent. Let's look at an example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// malicious-intent.com\\n// makes an authenticated request as on your behalf\\n\\nconst maliciousRequest = await fetch(`https://payload-finances.com/api/me`, {\\n  credentials: 'include',\\n}).then((res) =\u003e await res.json())\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this scenario, if your cookie was still valid, malicious-intent.com would be able to make requests like the one above on your behalf. This is a CSRF attack.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CSRF Prevention\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Define domains that your trust and are willing to accept Payload HTTP-only cookie based requests from. Use the \", _jsx(_components.code, {\n        children: \"csrf\"\n      }), \" option on the base Payload Config to do this:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// payload.config.ts\\n\\nimport { buildConfig } from 'payload'\\n\\nconst config = buildConfig({\\n  serverURL: 'https://my-payload-instance.com',\\n  // highlight-start\\n  csrf: [\\n    // whitelist of domains to allow cookie auth from\\n    'https://your-frontend-app.com',\\n    'https://your-other-frontend-app.com',\\n    // `config.serverURL` is added by default if defined\\n  ],\\n  // highlight-end\\n  collections: [\\n    // collections here\\n  ],\\n})\\n\\nexport default config\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Cross domain authentication\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your frontend is on a different domain than your Payload API then you will not be able to use HTTP-only cookies for authentication by default as they will be considered third-party cookies by the browser.\\nThere are a few strategies to get around this:\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"1. Use subdomains\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cookies can cross subdomains without being considered third party cookies, for example if your API is at api.example.com then you can authenticate from example.com.\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"2. Configure cookies\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If option 1 isn't possible, then you can get around this limitation by \", _jsx(_components.a, {\n        href: \"./overview#config-options\",\n        children: \"configuring your cookies\"\n      }), \" on your authentication collection to achieve the following setup:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"SameSite: None // allows the cookie to cross domains\\nSecure: true // ensures its sent over HTTPS only\\nHttpOnly: true // ensures its not accessible via client side JavaScript\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Configuration example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"{\\n  slug: 'users',\\n  auth: {\\n    cookies: {\\n      sameSite: 'None',\\n      secure: true,\\n    }\\n  },\\n  fields: [\\n    // your auth fields here\\n  ]\\n},\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you're configuring \", _jsx(_components.a, {\n        href: \"../production/preventing-abuse#cross-origin-resource-sharing-cors\",\n        children: \"cors\"\n      }), \" in your Payload config, you won't be able to use a wildcard anymore, you'll need to specify the list of allowed domains.\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Good to know:\"\n        }), \" Setting up \", _jsx(_components.code, {\n          children: \"secure: true\"\n        }), \" will not work if you're developing\\non \", _jsx(_components.code, {\n          children: \"http://localhost\"\n        }), \" or any non-https domain. For local development you\\nshould conditionally set this to \", _jsx(_components.code, {\n          children: \"false\"\n        }), \" based on the environment.\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["authentication","cookies"]},"buildId":"rEpVRygLyV6yJ0i_Ohw0C","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>