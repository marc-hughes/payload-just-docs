<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">API Key Strategy</h1><p class="text-xl text-gray-600 mb-8">Enable API key based authentication to interface with Payload.</p><div class="prose prose-lg max-w-none"><p>To integrate with third-party APIs or services, you might need the ability to generate API keys that can be used to identify as a certain user within Payload. API keys are generated on a user-by-user basis, similar to email and passwords, and are meant to represent a single user.</p>
<p>For example, if you have a third-party service or external app that needs to be able to perform protected actions against Payload, first you need to create a user within Payload, i.e. <code>dev@thirdparty.com</code>. From your external application you will need to authenticate with that user, you have two options:</p>
<ol>
<li>Log in each time with that user and receive an expiring token to request with.</li>
<li>Generate a non-expiring API key for that user to request with.</li>
</ol>
<div class="p-4 my-4 rounded-lg border bg-green-50 border-green-200 text-green-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg><p><strong>Tip:</strong></p><p>This is particularly useful as you can create a &quot;user&quot; that reflects an integration with a specific external service and assign a &quot;role&quot; or specific access only needed by that service/integration.</p></div>
<p>Technically, both of these options will work for third-party integrations but the second option with API key is simpler, because it reduces the amount of work that your integrations need to do to be authenticated properly.</p>
<p>To enable API keys on a collection, set the <code>useAPIKey</code> auth option to <code>true</code>. From there, a new interface will appear in the <a href="../admin/overview">Admin Panel</a> for each document within the collection that allows you to generate an API key for each user in the Collection.</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

export const ThirdPartyAccess: CollectionConfig = {
  slug: &#x27;third-party-access&#x27;,
  auth: {
    useAPIKey: true, // highlight-line
  },
  fields: [],
}
</code></pre>
<p>User API keys are encrypted within the database, meaning that if your database is compromised,
your API keys will not be.</p>
<div class="p-4 my-4 rounded-lg border bg-yellow-50 border-yellow-200 text-yellow-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg><p><strong>Important:</strong>
If you change your <code>PAYLOAD_SECRET</code>, you will need to regenerate your API keys.</p><p>The secret key is used to encrypt the API keys, so if you change the secret, existing API keys will
no longer be valid.</p></div>
<h3>HTTP Authentication</h3>
<p>To authenticate REST or GraphQL API requests using an API key, set the <code>Authorization</code> header. The header is case-sensitive and needs the slug of the <code>auth.useAPIKey</code> enabled collection, then &quot; API-Key &quot;, followed by the <code>apiKey</code> that has been assigned. Payload&#x27;s built-in middleware will then assign the user document to <code>req.user</code> and handle requests with the proper <a href="../access-control/overview">Access Control</a>. By doing this, Payload recognizes the request being made as a request by the user associated with that API key.</p>
<p><strong>For example, using Fetch:</strong></p>
<pre><code class="language-ts">import Users from &#x27;../collections/Users&#x27;

const response = await fetch(&#x27;http://localhost:3000/api/pages&#x27;, {
  headers: {
    Authorization: `${Users.slug} API-Key ${YOUR_API_KEY}`,
  },
})
</code></pre>
<p>Payload ensures that the same, uniform <a href="../access-control/overview">Access Control</a> is used across all authentication strategies. This enables you to utilize your existing Access Control configurations with both API keys and the standard email/password authentication. This consistency can aid in maintaining granular control over your API keys.</p>
<h3>API Key Only Auth</h3>
<p>If you want to use API keys as the only authentication method for a collection, you can disable the default local strategy by setting <code>disableLocalStrategy</code> to <code>true</code> on the collection&#x27;s <code>auth</code> property. This will disable the ability to authenticate with email and password, and will only allow for authentication via API key.</p>
<pre><code class="language-ts">import type { CollectionConfig } from &#x27;payload&#x27;

export const ThirdPartyAccess: CollectionConfig = {
  slug: &#x27;third-party-access&#x27;,
  auth: {
    useAPIKey: true,
    disableLocalStrategy: true, // highlight-line
  },
}
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"API Key Strategy","label":"API Key Strategy","order":50,"desc":"Enable API key based authentication to interface with Payload.","keywords":"authentication, config, configuration, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    a: \"a\",\n    pre: \"pre\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"To integrate with third-party APIs or services, you might need the ability to generate API keys that can be used to identify as a certain user within Payload. API keys are generated on a user-by-user basis, similar to email and passwords, and are meant to represent a single user.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, if you have a third-party service or external app that needs to be able to perform protected actions against Payload, first you need to create a user within Payload, i.e. \", _jsx(_components.code, {\n        children: \"dev@thirdparty.com\"\n      }), \". From your external application you will need to authenticate with that user, you have two options:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Log in each time with that user and receive an expiring token to request with.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Generate a non-expiring API key for that user to request with.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"success\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Tip:\"\n        })\n      }), _jsx(_components.p, {\n        children: \"This is particularly useful as you can create a \\\"user\\\" that reflects an integration with a specific external service and assign a \\\"role\\\" or specific access only needed by that service/integration.\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Technically, both of these options will work for third-party integrations but the second option with API key is simpler, because it reduces the amount of work that your integrations need to do to be authenticated properly.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To enable API keys on a collection, set the \", _jsx(_components.code, {\n        children: \"useAPIKey\"\n      }), \" auth option to \", _jsx(_components.code, {\n        children: \"true\"\n      }), \". From there, a new interface will appear in the \", _jsx(_components.a, {\n        href: \"../admin/overview\",\n        children: \"Admin Panel\"\n      }), \" for each document within the collection that allows you to generate an API key for each user in the Collection.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nexport const ThirdPartyAccess: CollectionConfig = {\\n  slug: 'third-party-access',\\n  auth: {\\n    useAPIKey: true, // highlight-line\\n  },\\n  fields: [],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"User API keys are encrypted within the database, meaning that if your database is compromised,\\nyour API keys will not be.\"\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"warning\",\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Important:\"\n        }), \"\\nIf you change your \", _jsx(_components.code, {\n          children: \"PAYLOAD_SECRET\"\n        }), \", you will need to regenerate your API keys.\"]\n      }), _jsx(_components.p, {\n        children: \"The secret key is used to encrypt the API keys, so if you change the secret, existing API keys will\\nno longer be valid.\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"HTTP Authentication\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To authenticate REST or GraphQL API requests using an API key, set the \", _jsx(_components.code, {\n        children: \"Authorization\"\n      }), \" header. The header is case-sensitive and needs the slug of the \", _jsx(_components.code, {\n        children: \"auth.useAPIKey\"\n      }), \" enabled collection, then \\\" API-Key \\\", followed by the \", _jsx(_components.code, {\n        children: \"apiKey\"\n      }), \" that has been assigned. Payload's built-in middleware will then assign the user document to \", _jsx(_components.code, {\n        children: \"req.user\"\n      }), \" and handle requests with the proper \", _jsx(_components.a, {\n        href: \"../access-control/overview\",\n        children: \"Access Control\"\n      }), \". By doing this, Payload recognizes the request being made as a request by the user associated with that API key.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"For example, using Fetch:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import Users from '../collections/Users'\\n\\nconst response = await fetch('http://localhost:3000/api/pages', {\\n  headers: {\\n    Authorization: `${Users.slug} API-Key ${YOUR_API_KEY}`,\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload ensures that the same, uniform \", _jsx(_components.a, {\n        href: \"../access-control/overview\",\n        children: \"Access Control\"\n      }), \" is used across all authentication strategies. This enables you to utilize your existing Access Control configurations with both API keys and the standard email/password authentication. This consistency can aid in maintaining granular control over your API keys.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"API Key Only Auth\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you want to use API keys as the only authentication method for a collection, you can disable the default local strategy by setting \", _jsx(_components.code, {\n        children: \"disableLocalStrategy\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"true\"\n      }), \" on the collection's \", _jsx(_components.code, {\n        children: \"auth\"\n      }), \" property. This will disable the ability to authenticate with email and password, and will only allow for authentication via API key.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nexport const ThirdPartyAccess: CollectionConfig = {\\n  slug: 'third-party-access',\\n  auth: {\\n    useAPIKey: true,\\n    disableLocalStrategy: true, // highlight-line\\n  },\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["authentication","api-keys"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>