<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" as="style" crossorigin=""/><link rel="stylesheet" href="/payload-just-docs/_next/static/css/adeeaed65336a824.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/payload-just-docs/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/payload-just-docs/_next/static/chunks/webpack-c335844537ee4527.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/framework-fae63b21a27d6472.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/main-4b5290d5009800e1.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/_app-2747846ed27f1501.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/chunks/pages/docs/%5B...slug%5D-f6932393d0a8e091.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_buildManifest.js" defer="" crossorigin=""></script><script src="/payload-just-docs/_next/static/DHzIn8D_gRO4uRLrnkzxV/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="container mx-auto px-4 py-8 max-w-4xl"><h1 class="text-4xl font-bold mb-4">Transactions</h1><p class="text-xl text-gray-600 mb-8">Database transactions are fully supported within Payload.</p><div class="prose prose-lg max-w-none"><p>Database transactions allow your application to make a series of database changes in an all-or-nothing commit. Consider an HTTP request that creates a new <strong>Order</strong> and has an <code>afterChange</code> hook to update the stock count of related <strong>Items</strong>. If an error occurs when updating an <strong>Item</strong> and an HTTP error is returned to the user, you would not want the new <strong>Order</strong> to be persisted or any other items to be changed either. This kind of interaction with the database is handled seamlessly with transactions.</p>
<p>By default, Payload will use transactions for all data changing operations, as long as it is supported by the configured database. Database changes are contained within all Payload operations and any errors thrown will result in all changes being rolled back without being committed. When transactions are not supported by the database, Payload will continue to operate as expected without them.</p>
<div class="p-4 my-4 rounded-lg border bg-blue-50 border-blue-200 text-blue-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg><p><strong>Note:</strong></p><p>MongoDB requires a connection to a replicaset in order to make use of transactions.</p></div>
<div class="p-4 my-4 rounded-lg border bg-blue-50 border-blue-200 text-blue-800"><svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg><p><strong>Note:</strong></p><p>Transactions in SQLite are disabled by default. You need to pass <code>transactionOptions: {}</code> to enable them.</p></div>
<p>The initial request made to Payload will begin a new transaction and attach it to the <code>req.transactionID</code>. If you have a <code>hook</code> that interacts with the database, you can opt in to using the same transaction by passing the <code>req</code> in the arguments. For example:</p>
<pre><code class="language-ts">const afterChange: CollectionAfterChangeHook = async ({ req }) =&gt; {
  // because req.transactionID is assigned from Payload and passed through,
  // my-slug will only persist if the entire request is successful
  await req.payload.create({
    req,
    collection: &#x27;my-slug&#x27;,
    data: {
      some: &#x27;data&#x27;,
    },
  })
}
</code></pre>
<h2>Async Hooks with Transactions</h2>
<p>Since Payload hooks can be async and be written to not await the result, it is possible to have an incorrect success response returned on a request that is rolled back. If you have a hook where you do not <code>await</code> the result, then you should <strong>not</strong> pass the <code>req.transactionID</code>.</p>
<pre><code class="language-ts">const afterChange: CollectionAfterChangeHook = async ({ req }) =&gt; {
  // WARNING: an async call made with the same req, but NOT awaited,
  // may fail resulting in an OK response being returned with response data that is not committed
  const dangerouslyIgnoreAsync = req.payload.create({
    req,
    collection: &#x27;my-slug&#x27;,
    data: {
      some: &#x27;other data&#x27;,
    },
  })

  // Should this call fail, it will not rollback other changes
  // because the req (and its transactionID) is not passed through
  const safelyIgnoredAsync = req.payload.create({
    collection: &#x27;my-slug&#x27;,
    data: {
      some: &#x27;other data&#x27;,
    },
  })
}
</code></pre>
<h2>Direct Transaction Access</h2>
<p>When writing your own scripts or custom endpoints, you may wish to have direct control over transactions. This is useful for interacting with your database outside of Payload&#x27;s Local API.</p>
<p>The following functions can be used for managing transactions:</p>
<ul>
<li><code>payload.db.beginTransaction</code> - Starts a new session and returns a transaction ID for use in other Payload Local API calls.</li>
<li><code>payload.db.commitTransaction</code> - Takes the identifier for the transaction, finalizes any changes.</li>
<li><code>payload.db.rollbackTransaction</code> - Takes the identifier for the transaction, discards any changes.</li>
</ul>
<p>Payload uses the <code>req</code> object to pass the transaction ID through to the database adapter. If you are not using the <code>req</code> object, you can make a new object to pass the transaction ID directly to database adapter methods and Local API calls.
Example:</p>
<pre><code class="language-ts">import payload from &#x27;payload&#x27;
import config from &#x27;./payload.config&#x27;

const standalonePayloadScript = async () =&gt; {
  // initialize Payload
  await payload.init({ config })

  const transactionID = await payload.db.beginTransaction()

  try {
    // Make an update using the Local API
    await payload.update({
      collection: &#x27;posts&#x27;,
      data: {
        some: &#x27;data&#x27;,
      },
      where: {
        slug: { equals: &#x27;my-slug&#x27; },
      },
      req: { transactionID },
    })

    /*
      You can make additional db changes or run other functions
      that need to be committed on an all or nothing basis
     */

    // Commit the transaction
    await payload.db.commitTransaction(transactionID)
  } catch (error) {
    // Rollback the transaction
    await payload.db.rollbackTransaction(transactionID)
  }
}

standalonePayloadScript()
</code></pre>
<h2>Disabling Transactions</h2>
<p>If you wish to disable transactions entirely, you can do so by passing <code>false</code> as the <code>transactionOptions</code> in your database adapter configuration. All the official Payload database adapters support this option.</p>
<p>In addition to allowing database transactions to be disabled at the adapter level. You can prevent Payload from using a transaction in direct calls to the Local API by adding <code>disableTransaction: true</code> to the args. For example:</p>
<pre><code class="language-ts">await payload.update({
  collection: &#x27;posts&#x27;,
  data: {
    some: &#x27;data&#x27;,
  },
  where: {
    slug: { equals: &#x27;my-slug&#x27; },
  },
  disableTransaction: true,
})
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontMatter":{"title":"Transactions","label":"Transactions","order":30,"keywords":"database, transactions, sql, mongodb, postgres, documentation, Content Management System, cms, headless, typescript, node, react, nextjs","desc":"Database transactions are fully supported within Payload."},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    pre: \"pre\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Database transactions allow your application to make a series of database changes in an all-or-nothing commit. Consider an HTTP request that creates a new \", _jsx(_components.strong, {\n        children: \"Order\"\n      }), \" and has an \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook to update the stock count of related \", _jsx(_components.strong, {\n        children: \"Items\"\n      }), \". If an error occurs when updating an \", _jsx(_components.strong, {\n        children: \"Item\"\n      }), \" and an HTTP error is returned to the user, you would not want the new \", _jsx(_components.strong, {\n        children: \"Order\"\n      }), \" to be persisted or any other items to be changed either. This kind of interaction with the database is handled seamlessly with transactions.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By default, Payload will use transactions for all data changing operations, as long as it is supported by the configured database. Database changes are contained within all Payload operations and any errors thrown will result in all changes being rolled back without being committed. When transactions are not supported by the database, Payload will continue to operate as expected without them.\"\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"info\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Note:\"\n        })\n      }), _jsx(_components.p, {\n        children: \"MongoDB requires a connection to a replicaset in order to make use of transactions.\"\n      })]\n    }), \"\\n\", _jsxs(Banner, {\n      type: \"info\",\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Note:\"\n        })\n      }), _jsxs(_components.p, {\n        children: [\"Transactions in SQLite are disabled by default. You need to pass \", _jsx(_components.code, {\n          children: \"transactionOptions: {}\"\n        }), \" to enable them.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The initial request made to Payload will begin a new transaction and attach it to the \", _jsx(_components.code, {\n        children: \"req.transactionID\"\n      }), \". If you have a \", _jsx(_components.code, {\n        children: \"hook\"\n      }), \" that interacts with the database, you can opt in to using the same transaction by passing the \", _jsx(_components.code, {\n        children: \"req\"\n      }), \" in the arguments. For example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const afterChange: CollectionAfterChangeHook = async ({ req }) =\u003e {\\n  // because req.transactionID is assigned from Payload and passed through,\\n  // my-slug will only persist if the entire request is successful\\n  await req.payload.create({\\n    req,\\n    collection: 'my-slug',\\n    data: {\\n      some: 'data',\\n    },\\n  })\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Async Hooks with Transactions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since Payload hooks can be async and be written to not await the result, it is possible to have an incorrect success response returned on a request that is rolled back. If you have a hook where you do not \", _jsx(_components.code, {\n        children: \"await\"\n      }), \" the result, then you should \", _jsx(_components.strong, {\n        children: \"not\"\n      }), \" pass the \", _jsx(_components.code, {\n        children: \"req.transactionID\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const afterChange: CollectionAfterChangeHook = async ({ req }) =\u003e {\\n  // WARNING: an async call made with the same req, but NOT awaited,\\n  // may fail resulting in an OK response being returned with response data that is not committed\\n  const dangerouslyIgnoreAsync = req.payload.create({\\n    req,\\n    collection: 'my-slug',\\n    data: {\\n      some: 'other data',\\n    },\\n  })\\n\\n  // Should this call fail, it will not rollback other changes\\n  // because the req (and its transactionID) is not passed through\\n  const safelyIgnoredAsync = req.payload.create({\\n    collection: 'my-slug',\\n    data: {\\n      some: 'other data',\\n    },\\n  })\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Direct Transaction Access\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When writing your own scripts or custom endpoints, you may wish to have direct control over transactions. This is useful for interacting with your database outside of Payload's Local API.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following functions can be used for managing transactions:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"payload.db.beginTransaction\"\n        }), \" - Starts a new session and returns a transaction ID for use in other Payload Local API calls.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"payload.db.commitTransaction\"\n        }), \" - Takes the identifier for the transaction, finalizes any changes.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"payload.db.rollbackTransaction\"\n        }), \" - Takes the identifier for the transaction, discards any changes.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload uses the \", _jsx(_components.code, {\n        children: \"req\"\n      }), \" object to pass the transaction ID through to the database adapter. If you are not using the \", _jsx(_components.code, {\n        children: \"req\"\n      }), \" object, you can make a new object to pass the transaction ID directly to database adapter methods and Local API calls.\\nExample:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import payload from 'payload'\\nimport config from './payload.config'\\n\\nconst standalonePayloadScript = async () =\u003e {\\n  // initialize Payload\\n  await payload.init({ config })\\n\\n  const transactionID = await payload.db.beginTransaction()\\n\\n  try {\\n    // Make an update using the Local API\\n    await payload.update({\\n      collection: 'posts',\\n      data: {\\n        some: 'data',\\n      },\\n      where: {\\n        slug: { equals: 'my-slug' },\\n      },\\n      req: { transactionID },\\n    })\\n\\n    /*\\n      You can make additional db changes or run other functions\\n      that need to be committed on an all or nothing basis\\n     */\\n\\n    // Commit the transaction\\n    await payload.db.commitTransaction(transactionID)\\n  } catch (error) {\\n    // Rollback the transaction\\n    await payload.db.rollbackTransaction(transactionID)\\n  }\\n}\\n\\nstandalonePayloadScript()\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Disabling Transactions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you wish to disable transactions entirely, you can do so by passing \", _jsx(_components.code, {\n        children: \"false\"\n      }), \" as the \", _jsx(_components.code, {\n        children: \"transactionOptions\"\n      }), \" in your database adapter configuration. All the official Payload database adapters support this option.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In addition to allowing database transactions to be disabled at the adapter level. You can prevent Payload from using a transaction in direct calls to the Local API by adding \", _jsx(_components.code, {\n        children: \"disableTransaction: true\"\n      }), \" to the args. For example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"await payload.update({\\n  collection: 'posts',\\n  data: {\\n    some: 'data',\\n  },\\n  where: {\\n    slug: { equals: 'my-slug' },\\n  },\\n  disableTransaction: true,\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/docs/[...slug]","query":{"slug":["database","transactions"]},"buildId":"DHzIn8D_gRO4uRLrnkzxV","assetPrefix":"/payload-just-docs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>