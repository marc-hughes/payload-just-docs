{"pageProps":{"frontMatter":{"title":"Jobs","label":"Jobs","order":40,"desc":"A Job is a set of work that is offloaded from your APIs and will be processed at a later date.","keywords":"jobs queue, application framework, typescript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    h4: \"h4\",\n    pre: \"pre\",\n    h5: \"h5\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Now that we have covered Tasks and Workflows, we can tie them together with a concept called a Job.\"\n    }), \"\\n\", _jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"Whereas you define Workflows and Tasks, which control your business logic, a\\n\", _jsx(_components.strong, {\n          children: \"Job\"\n        }), \" is an individual instance of either a Task or a Workflow which\\ncontains many tasks.\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, let's say we have a Workflow or Task that describes the logic to sync information from Payload to a third-party system. This is how you'd declare how to sync that info, but it wouldn't do anything on its own. In order to run that task or workflow, you'd create a Job that references the corresponding Task or Workflow.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Jobs are stored in the Payload database in the \", _jsx(_components.code, {\n        children: \"payload-jobs\"\n      }), \" collection, and you can decide to keep a running list of all jobs, or configure Payload to delete the job when it has been successfully executed.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Queuing a new job\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to queue a job, you can use the \", _jsx(_components.code, {\n        children: \"payload.jobs.queue\"\n      }), \" function.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here's how you'd queue a new Job, which will run a \", _jsx(_components.code, {\n        children: \"createPostAndUpdate\"\n      }), \" workflow:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const createdJob = await payload.jobs.queue({\\n  // Pass the name of the workflow\\n  workflow: 'createPostAndUpdate',\\n  // The input type will be automatically typed\\n  // according to the input you've defined for this workflow\\n  input: {\\n    title: 'my title',\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In addition to being able to queue new Jobs based on Workflows, you can also queue a job for a single Task:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const createdJob = await payload.jobs.queue({\\n  task: 'createPost',\\n  input: {\\n    title: 'my title',\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Cancelling Jobs\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Payload allows you to cancel jobs that are either queued or currently running. When cancelling a running job, the current task will finish executing, but no subsequent tasks will run. This happens because the job checks its cancellation status between tasks.\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Cancel a Single Job\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To cancel a specific job, use the \", _jsx(_components.code, {\n        children: \"payload.jobs.cancelByID\"\n      }), \" method with the job's ID:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"await payload.jobs.cancelByID({\\n  id: createdJob.id,\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"Cancel Multiple Jobs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To cancel multiple jobs at once, use the \", _jsx(_components.code, {\n        children: \"payload.jobs.cancel\"\n      }), \" method with a \", _jsx(_components.code, {\n        children: \"Where\"\n      }), \" query:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"await payload.jobs.cancel({\\n  where: {\\n    workflowSlug: {\\n      equals: 'createPost',\\n    },\\n  },\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}