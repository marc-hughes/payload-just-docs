{"pageProps":{"frontMatter":{"title":"Queues","label":"Queues","order":50,"desc":"A Queue is a specific group of jobs which can be executed in the order that they were added.","keywords":"jobs queue, application framework, typescript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    strong: \"strong\",\n    code: \"code\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    h3: \"h3\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Queues are the final aspect of Payload's Jobs Queue and deal with how to \", _jsx(_components.em, {\n        children: \"run your jobs\"\n      }), \". Up to this point, all we've covered is how to queue up jobs to run, but so far, we aren't actually running any jobs.\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"Queue\"\n        }), \" is a grouping of jobs that should be executed in order of when\\nthey were added.\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When you go to run jobs, Payload will query for any jobs that are added to the queue and then run them. By default, all queued jobs are added to the \", _jsx(_components.code, {\n        children: \"default\"\n      }), \" queue.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"But, imagine if you wanted to have some jobs that run nightly, and other jobs which should run every five minutes.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By specifying the \", _jsx(_components.code, {\n        children: \"queue\"\n      }), \" name when you queue a new job using \", _jsx(_components.code, {\n        children: \"payload.jobs.queue()\"\n      }), \", you can queue certain jobs with \", _jsx(_components.code, {\n        children: \"queue: 'nightly'\"\n      }), \", and other jobs can be left as the default queue.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, you could configure two different runner strategies:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.code, {\n          children: \"cron\"\n        }), \" that runs nightly, querying for jobs added to the \", _jsx(_components.code, {\n          children: \"nightly\"\n        }), \" queue\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Another that runs any jobs that were added to the \", _jsx(_components.code, {\n          children: \"default\"\n        }), \" queue every ~5 minutes or so\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Executing jobs\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As mentioned above, you can queue jobs, but the jobs won't run unless a worker picks up your jobs and runs them. This can be done in four ways:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Cron jobs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can use the \", _jsx(_components.code, {\n        children: \"jobs.autoRun\"\n      }), \" property to configure cron jobs:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // Other configurations...\\n  jobs: {\\n    tasks: [\\n      // your tasks here\\n    ],\\n    // autoRun can optionally be a function that receives `payload` as an argument\\n    autoRun: [\\n      {\\n        cron: '0 * * * *', // every hour at minute 0\\n        limit: 100, // limit jobs to process each run\\n        queue: 'hourly', // name of the queue\\n      },\\n      // add as many cron jobs as you want\\n    ],\\n    shouldAutoRun: async (payload) => {\\n      // Tell Payload if it should run jobs or not.\\n      // This function will be invoked each time Payload goes to pick up and run jobs.\\n      // If this function ever returns false, the cron schedule will be stopped.\\n      return true\\n    },\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsx(_components.p, {\n        children: \"autoRun is intended for use with a dedicated server that is always running,\\nand should not be used on serverless platforms like Vercel.\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Endpoint\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can execute jobs by making a fetch request to the \", _jsx(_components.code, {\n        children: \"/api/payload-jobs/run\"\n      }), \" endpoint:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// Here, we're saying we want to run only 100 jobs for this invocation\\n// and we want to pull jobs from the `nightly` queue:\\nawait fetch('/api/payload-jobs/run?limit=100&queue=nightly', {\\n  method: 'GET',\\n  headers: {\\n    Authorization: `Bearer ${token}`,\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This endpoint is automatically mounted for you and is helpful in conjunction with serverless platforms like Vercel, where you might want to use Vercel Cron to invoke a serverless function that executes your jobs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Vercel Cron Example\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you're deploying on Vercel, you can add a \", _jsx(_components.code, {\n        children: \"vercel.json\"\n      }), \" file in the root of your project that configures Vercel Cron to invoke the \", _jsx(_components.code, {\n        children: \"run\"\n      }), \" endpoint on a cron schedule.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here's an example of what this file will look like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"crons\\\": [\\n    {\\n      \\\"path\\\": \\\"/api/payload-jobs/run\\\",\\n      \\\"schedule\\\": \\\"*/5 * * * *\\\"\\n    }\\n  ]\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The configuration above schedules the endpoint \", _jsx(_components.code, {\n        children: \"/api/payload-jobs/run\"\n      }), \" to be invoked every 5 minutes.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The last step will be to secure your \", _jsx(_components.code, {\n        children: \"run\"\n      }), \" endpoint so that only the proper users can invoke the runner.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To do this, you can set an environment variable on your Vercel project called \", _jsx(_components.code, {\n        children: \"CRON_SECRET\"\n      }), \", which should be a random stringâ€”ideally 16 characters or longer.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, you can modify the \", _jsx(_components.code, {\n        children: \"access\"\n      }), \" function for running jobs by ensuring that only Vercel can invoke your runner.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // Other configurations...\\n  jobs: {\\n    access: {\\n      run: ({ req }: { req: PayloadRequest }): boolean => {\\n        // Allow logged in users to execute this endpoint (default)\\n        if (req.user) return true\\n\\n        // If there is no logged in user, then check\\n        // for the Vercel Cron secret to be present as an\\n        // Authorization header:\\n        const authHeader = req.headers.get('authorization')\\n        return authHeader === `Bearer ${process.env.CRON_SECRET}`\\n      },\\n    },\\n    // Other job configurations...\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This works because Vercel automatically makes the \", _jsx(_components.code, {\n        children: \"CRON_SECRET\"\n      }), \" environment variable available to the endpoint as the \", _jsx(_components.code, {\n        children: \"Authorization\"\n      }), \" header when triggered by the Vercel Cron, ensuring that the jobs can be run securely.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"After the project is deployed to Vercel, the Vercel Cron job will automatically trigger the \", _jsx(_components.code, {\n        children: \"/api/payload-jobs/run\"\n      }), \" endpoint in the specified schedule, running the queued jobs in the background.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Local API\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you want to process jobs programmatically from your server-side code, you can use the Local API:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Run all jobs:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const results = await payload.jobs.run()\\n\\n// You can customize the queue name and limit by passing them as arguments:\\nawait payload.jobs.run({ queue: 'nightly', limit: 100 })\\n\\n// You can provide a where clause to filter the jobs that should be run:\\nawait payload.jobs.run({\\n  where: { 'input.message': { equals: 'secret' } },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Run a single job:\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const results = await payload.jobs.runByID({\\n  id: myJobID,\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Bin script\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, you can process jobs via the bin script that comes with Payload out of the box.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"npx payload jobs:run --queue default --limit 10\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In addition, the bin script allows you to pass a \", _jsx(_components.code, {\n        children: \"--cron\"\n      }), \" flag to the \", _jsx(_components.code, {\n        children: \"jobs:run\"\n      }), \" command to run the jobs on a scheduled, cron basis:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sh\",\n        children: \"npx payload jobs:run --cron \\\"*/5 * * * *\\\"\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Processing Order\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By default, jobs are processed first in, first out (FIFO). This means that the first job added to the queue will be the first one processed. However, you can also configure the order in which jobs are processed.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Jobs Configuration\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can configure the order in which jobs are processed in the jobs configuration by passing the \", _jsx(_components.code, {\n        children: \"processingOrder\"\n      }), \" property. This mimics the Payload \", _jsx(_components.a, {\n        href: \"../queries/sort\",\n        children: \"sort\"\n      }), \" property that's used for functionality such as \", _jsx(_components.code, {\n        children: \"payload.find()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // Other configurations...\\n  jobs: {\\n    tasks: [\\n      // your tasks here\\n    ],\\n    processingOrder: '-createdAt', // Process jobs in reverse order of creation = LIFO\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can also set this on a queue-by-queue basis:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // Other configurations...\\n  jobs: {\\n    tasks: [\\n      // your tasks here\\n    ],\\n    processingOrder: {\\n      default: 'createdAt', // FIFO\\n      queues: {\\n        nightly: '-createdAt', // LIFO\\n        myQueue: '-createdAt', // LIFO\\n      },\\n    },\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you need even more control over the processing order, you can pass a function that returns the processing order - this function will be called every time a queue starts processing jobs.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"export default buildConfig({\\n  // Other configurations...\\n  jobs: {\\n    tasks: [\\n      // your tasks here\\n    ],\\n    processingOrder: ({ queue }) => {\\n      if (queue === 'myQueue') {\\n        return '-createdAt' // LIFO\\n      }\\n      return 'createdAt' // FIFO\\n    },\\n  },\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Local API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can configure the order in which jobs are processed in the \", _jsx(_components.code, {\n        children: \"payload.jobs.queue\"\n      }), \" method by passing the \", _jsx(_components.code, {\n        children: \"processingOrder\"\n      }), \" property.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const createdJob = await payload.jobs.queue({\\n  workflow: 'createPostAndUpdate',\\n  input: {\\n    title: 'my title',\\n  },\\n  processingOrder: '-createdAt', // Process jobs in reverse order of creation = LIFO\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}