{"pageProps":{"frontMatter":{"title":"Converting Plaintext","label":"Converting Plaintext","order":24,"desc":"Converting between lexical richtext and plaintext","keywords":"lexical, richtext, plaintext, text"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Richtext to Plaintext\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here's how you can convert richtext data to plaintext using \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/plaintext\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { convertLexicalToPlaintext } from '@payloadcms/richtext-lexical/plaintext'\\n\\n// Your richtext data here\\nconst data: SerializedEditorState = {}\\n\\nconst plaintext = convertLexicalToPlaintext({ data })\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Custom Converters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"convertLexicalToPlaintext\"\n      }), \" functions accepts a \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" object that allows you to customize how specific nodes are converted to plaintext.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport type { MyTextBlock } from '@/payload-types'\\n\\nimport {\\n  convertLexicalToPlaintext,\\n  type PlaintextConverters,\\n} from '@payloadcms/richtext-lexical/plaintext'\\n\\n// Your richtext data here\\nconst data: SerializedEditorState = {}\\n\\nconst converters: PlaintextConverters<\\n  DefaultNodeTypes | SerializedBlockNode<MyTextBlock>\\n> = {\\n  blocks: {\\n    textBlock: ({ node }) => {\\n      return node.fields.text ?? ''\\n    },\\n  },\\n  link: ({ node }) => {\\n    return node.fields.url ?? ''\\n  },\\n}\\n\\nconst plaintext = convertLexicalToPlaintext({\\n  converters,\\n  data,\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Unlike other converters, there are no default converters for plaintext.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If a node does not have a converter defined, the following heuristics are used to convert it to plaintext:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"If the node has a \", _jsx(_components.code, {\n          children: \"text\"\n        }), \" field, it will be used as the plaintext.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"If the node has a \", _jsx(_components.code, {\n          children: \"children\"\n        }), \" field, the children will be recursively converted to plaintext.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If the node has neither, it will be ignored.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Paragraph, text and tab nodes insert newline / tab characters.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}