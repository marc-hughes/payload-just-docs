{"pageProps":{"frontMatter":{"title":"Context","label":"Context","order":50,"desc":"Context allows you to pass in extra data that can be shared between hooks","keywords":"hooks, context, payload context, payloadcontext, data, extra data, shared data, shared, extra"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"context\"\n      }), \" object is used to share data across different Hooks. This persists throughout the entire lifecycle of a request and is available within every Hook. By setting properties to \", _jsx(_components.code, {\n        children: \"req.context\"\n      }), \", you can effectively share logic across multiple Hooks.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"When To Use Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Context gives you a way forward on otherwise difficult problems such as:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data between Hooks\"\n        }), \": Needing data in multiple Hooks from a 3rd party API, it could be retrieved and used in \", _jsx(_components.code, {\n          children: \"beforeChange\"\n        }), \" and later used again in an \", _jsx(_components.code, {\n          children: \"afterChange\"\n        }), \" hook without having to fetch it twice.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Preventing infinite loops\"\n        }), \": Calling \", _jsx(_components.code, {\n          children: \"payload.update()\"\n        }), \" on the same document that triggered an \", _jsx(_components.code, {\n          children: \"afterChange\"\n        }), \" hook will create an infinite loop, control the flow by assigning a no-op condition to context\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data to Local API\"\n        }), \": Setting values on the \", _jsx(_components.code, {\n          children: \"req.context\"\n        }), \" and pass it to \", _jsx(_components.code, {\n          children: \"payload.create()\"\n        }), \" you can provide additional data to hooks without adding extraneous fields.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Passing data between hooks and middleware or custom endpoints\"\n        }), \": Hooks could set context across multiple collections and then be used in a final \", _jsx(_components.code, {\n          children: \"postMiddleware\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How To Use Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's see examples on how context can be used in the first two scenarios mentioned above:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Passing Data Between Hooks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To pass data between hooks, you can assign values to context in an earlier hook in the lifecycle of a request and expect it the context in a later hook.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst Customer: CollectionConfig = {\\n  slug: 'customers',\\n  hooks: {\\n    beforeChange: [\\n      async ({ context, data }) => {\\n        // assign the customerData to context for use later\\n        context.customerData = await fetchCustomerData(data.customerID)\\n        return {\\n          ...data,\\n          // some data we use here\\n          name: context.customerData.name,\\n        }\\n      },\\n    ],\\n    afterChange: [\\n      async ({ context, doc, req }) => {\\n        // use context.customerData without needing to fetch it again\\n        if (context.customerData.contacted === false) {\\n          createTodo('Call Customer', context.customerData)\\n        }\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Preventing Infinite Loops\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's say you have an \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook, and you want to do a calculation inside the hook (as the document ID needed for the calculation is available in the \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook, but not in the \", _jsx(_components.code, {\n        children: \"beforeChange\"\n      }), \" hook). Once that's done, you want to update the document with the result of the calculation.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bad example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst Customer: CollectionConfig = {\\n  slug: 'customers',\\n  hooks: {\\n    afterChange: [\\n      async ({ doc, req }) => {\\n        await req.payload.update({\\n          // DANGER: updating the same slug as the collection in an afterChange will create an infinite loop!\\n          collection: 'customers',\\n          id: doc.id,\\n          data: {\\n            ...(await fetchCustomerData(data.customerID)),\\n          },\\n        })\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead of the above, we need to tell the \", _jsx(_components.code, {\n        children: \"afterChange\"\n      }), \" hook to not run again if it performs the update (and thus not update itself again). We can solve that with context.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fixed example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig } from 'payload'\\n\\nconst MyCollection: CollectionConfig = {\\n  slug: 'slug',\\n  hooks: {\\n    afterChange: [\\n      async ({ context, doc, req }) => {\\n        // return if flag was previously set\\n        if (context.triggerAfterChange === false) {\\n          return\\n        }\\n        await req.payload.update({\\n          collection: contextHooksSlug,\\n          id: doc.id,\\n          data: {\\n            ...(await fetchCustomerData(data.customerID)),\\n          },\\n          context: {\\n            // set a flag to prevent from running again\\n            triggerAfterChange: false,\\n          },\\n        })\\n      },\\n    ],\\n  },\\n  fields: [\\n    /* ... */\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"TypeScript\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The default TypeScript interface for \", _jsx(_components.code, {\n        children: \"context\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"{ [key: string]: unknown }\"\n      }), \". If you prefer a more strict typing in your project or when authoring plugins for others, you can override this using the \", _jsx(_components.code, {\n        children: \"declare\"\n      }), \" syntax.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is known as \\\"type augmentation\\\", a TypeScript feature which allows us to add types to existing types. Simply put this in any \", _jsx(_components.code, {\n        children: \".ts\"\n      }), \" or \", _jsx(_components.code, {\n        children: \".d.ts\"\n      }), \" file:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { RequestContext as OriginalRequestContext } from 'payload'\\n\\ndeclare module 'payload' {\\n  // Create a new interface that merges your additional fields with the original one\\n  export interface RequestContext extends OriginalRequestContext {\\n    myObject?: string\\n    // ...\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This will add the property \", _jsx(_components.code, {\n        children: \"myObject\"\n      }), \" with a type of string to every context object. Make sure to follow this example correctly, as type augmentation can mess up your types if you do it wrong.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}