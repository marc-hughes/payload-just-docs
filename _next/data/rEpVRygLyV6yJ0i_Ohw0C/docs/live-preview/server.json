{"pageProps":{"frontMatter":{"title":"Server-side Live Preview","label":"Server-side","order":30,"desc":"Learn how to implement Live Preview in your server-side front-end application.","keywords":"live preview, frontend, react, next.js, vue, nuxt.js, svelte, hook, useLivePreview"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    pre: \"pre\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    strong: \"strong\",\n    h4: \"h4\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Banner, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"Server-side Live Preview is only for front-end frameworks that support the\\nconcept of Server Components, i.e. \", _jsx(_components.a, {\n          href: \"https://react.dev/reference/rsc/server-components\",\n          children: \"React Server\\nComponents\"\n        }), \". If your\\nfront-end application is built with a client-side framework like the \", _jsx(_components.a, {\n          href: \"https://nextjs.org/docs/pages\",\n          children: \"Next.js\\nPages Router\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://reactrouter.com\",\n          children: \"React\\nRouter\"\n        }), \", \", _jsx(_components.a, {\n          href: \"https://vuejs.org\",\n          children: \"Vue 3\"\n        }), \", etc., see\\n\", _jsx(_components.a, {\n          href: \"./client\",\n          children: \"client-side Live Preview\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Server-side Live Preview works by making a roundtrip to the server every time your document is saved, i.e. draft save, autosave, or publish. While using Live Preview, the Admin Panel emits a new \", _jsx(_components.code, {\n        children: \"window.postMessage\"\n      }), \" event which your front-end application can use to invoke this process. In Next.js, this means simply calling \", _jsx(_components.code, {\n        children: \"router.refresh()\"\n      }), \" which will hydrate the HTML using new data straight from the \", _jsx(_components.a, {\n        href: \"../local-api/overview\",\n        children: \"Local API\"\n      }), \".\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"It is recommended that you enable \", _jsx(_components.a, {\n          href: \"../versions/autosave\",\n          children: \"Autosave\"\n        }), \" alongside\\nLive Preview to make the experience feel more responsive.\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application is built with \", _jsx(_components.a, {\n        href: \"#react\",\n        children: \"React\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnChange\"\n      }), \" function that Payload provides. In the future, all other major frameworks like Vue and Svelte will be officially supported. If you are using any of these frameworks today, you can still integrate with Live Preview yourself using the underlying tooling that Payload provides. See \", _jsx(_components.a, {\n        href: \"#building-your-own-router-refresh-component\",\n        children: \"building your own router refresh component\"\n      }), \" for more information.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application is built with server-side \", _jsx(_components.a, {\n        href: \"https://react.dev\",\n        children: \"React\"\n      }), \" like \", _jsx(_components.a, {\n        href: \"https://nextjs.org/docs/app\",\n        children: \"Next.js App Router\"\n      }), \", you can use the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" component that Payload provides.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, install the \", _jsx(_components.code, {\n        children: \"@payloadcms/live-preview-react\"\n      }), \" package:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install @payloadcms/live-preview-react\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, render the \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" component anywhere in your \", _jsx(_components.code, {\n        children: \"page.tsx\"\n      }), \". Here's an example:\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"page.tsx\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { RefreshRouteOnSave } from './RefreshRouteOnSave.tsx'\\nimport { getPayload } from 'payload'\\nimport config from '../payload.config'\\n\\nexport default async function Page() {\\n  const payload = await getPayload({ config })\\n\\n  const page = await payload.findByID({\\n    collection: 'pages',\\n    id: '123',\\n    draft: true,\\n  })\\n\\n  return (\\n    <Fragment>\\n      <RefreshRouteOnSave />\\n      <h1>{page.title}</h1>\\n    </Fragment>\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"RefreshRouteOnSave.tsx\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport { RefreshRouteOnSave as PayloadLivePreview } from '@payloadcms/live-preview-react'\\nimport { useRouter } from 'next/navigation.js'\\nimport React from 'react'\\n\\nexport const RefreshRouteOnSave: React.FC = () => {\\n  const router = useRouter()\\n\\n  return (\\n    <PayloadLivePreview\\n      refresh={() => router.refresh()}\\n      serverURL={process.env.NEXT_PUBLIC_PAYLOAD_URL}\\n    />\\n  )\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Building your own router refresh component\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"No matter what front-end framework you are using, you can build your own component using the same underlying tooling that Payload provides.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, install the base \", _jsx(_components.code, {\n        children: \"@payloadcms/live-preview\"\n      }), \" package:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"npm install @payloadcms/live-preview\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This package provides the following functions:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Path\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"ready\"\n              })\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Sends a \", _jsx(_components.code, {\n              children: \"window.postMessage\"\n            }), \" event to the Admin Panel to indicate that the front-end is ready to receive messages.\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"isDocumentEvent\"\n              })\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Checks if a \", _jsx(_components.code, {\n              children: \"MessageEvent\"\n            }), \" originates from the Admin Panel and is a document-level event, i.e. draft save, autosave, publish, etc.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With these functions, you can build your own hook using your front-end framework of choice:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import { ready, isDocumentEvent } from '@payloadcms/live-preview'\\n\\n// To build your own component:\\n// 1. Listen for document-level `window.postMessage` events sent from the Admin Panel\\n// 2. Tell the Admin Panel when it is ready to receive messages\\n// 3. Refresh the route every time a new document-level event is received\\n// 4. Unsubscribe from the `window.postMessage` events when it unmounts\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of what the same \", _jsx(_components.code, {\n        children: \"RefreshRouteOnSave\"\n      }), \" React component from above looks like under the hood:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type React from 'react'\\n\\nimport { isDocumentEvent, ready } from '@payloadcms/live-preview'\\nimport { useCallback, useEffect, useRef } from 'react'\\n\\nexport const RefreshRouteOnSave: React.FC<{\\n  apiRoute?: string\\n  depth?: number\\n  refresh: () => void\\n  serverURL: string\\n}> = (props) => {\\n  const { apiRoute, depth, refresh, serverURL } = props\\n  const hasSentReadyMessage = useRef<boolean>(false)\\n\\n  const onMessage = useCallback(\\n    (event: MessageEvent) => {\\n      if (isDocumentEvent(event, serverURL)) {\\n        if (typeof refresh === 'function') {\\n          refresh()\\n        }\\n      }\\n    },\\n    [refresh, serverURL],\\n  )\\n\\n  useEffect(() => {\\n    if (typeof window !== 'undefined') {\\n      window.addEventListener('message', onMessage)\\n    }\\n\\n    if (!hasSentReadyMessage.current) {\\n      hasSentReadyMessage.current = true\\n\\n      ready({\\n        serverURL,\\n      })\\n    }\\n\\n    return () => {\\n      if (typeof window !== 'undefined') {\\n        window.removeEventListener('message', onMessage)\\n      }\\n    }\\n  }, [serverURL, onMessage, depth, apiRoute])\\n\\n  return null\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For a working demonstration of this, check out the official \", _jsx(_components.a, {\n        href: \"https://github.com/payloadcms/payload/tree/main/examples/live-preview\",\n        children: \"Live Preview Example\"\n      }), \". There you will find a fully working example of how to implement Live Preview in your Next.js App Router application.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Troubleshooting\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Updates do not appear as fast as client-side Live Preview\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you are noticing that updates feel less snappy than client-side Live Preview (i.e. the \", _jsx(_components.code, {\n        children: \"useLivePreview\"\n      }), \" hook), this is because of how the two differ in how they work—instead of emitting events against \", _jsx(_components.em, {\n        children: \"form state\"\n      }), \", server-side Live Preview refreshes the route after a new document is \", _jsx(_components.em, {\n        children: \"saved\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use \", _jsx(_components.a, {\n        href: \"../versions/autosave\",\n        children: \"Autosave\"\n      }), \" to mimic this effect server-side. Try decreasing the value of \", _jsx(_components.code, {\n        children: \"versions.autoSave.interval\"\n      }), \" to make the experience feel more responsive:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// collection.ts\\n{\\n   versions: {\\n    drafts: {\\n      autosave: {\\n        interval: 375,\\n      },\\n    },\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Iframe refuses to connect\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If your front-end application has set a \", _jsx(_components.a, {\n        href: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\",\n        children: \"Content Security Policy\"\n      }), \" (CSP) that blocks the Admin Panel from loading your front-end application, the iframe will not be able to load your site. To resolve this, you can whitelist the Admin Panel's domain in your CSP by setting the \", _jsx(_components.code, {\n        children: \"frame-ancestors\"\n      }), \" directive:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: \"frame-ancestors: \\\"self\\\" localhost:* https://your-site.com;\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}