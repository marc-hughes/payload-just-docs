{"pageProps":{"frontMatter":{"title":"Lexical Converters","label":"Converters","order":20,"desc":"Conversion between lexical, markdown, jsx and html","keywords":"lexical, rich text, editor, headless cms, convert, html, mdx, markdown, md, conversion, export, jsx"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    h2: \"h2\",\n    code: \"code\",\n    h3: \"h3\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Richtext fields save data in JSON - this is great for storage and flexibility and allows you to easily to convert it to other formats:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-jsx\",\n          children: \"Converting JSX\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-html\",\n          children: \"Converting HTML\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-plaintext\",\n          children: \"Converting Plaintext\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"/docs/rich-text/converting-markdown\",\n          children: \"Converting Markdown and MDX\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Retrieving the Editor Config\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Some converters require access to the Lexical editor config, which defines available features and behaviors. Payload provides multiple ways to obtain the editor config through the \", _jsx(_components.code, {\n        children: \"editorConfigFactory\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Importing the Factory\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, import the necessary utilities:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { SanitizedConfig } from 'payload'\\nimport { editorConfigFactory } from '@payloadcms/richtext-lexical'\\n\\n// Your Payload Config needs to be available in order to retrieve the default editor config\\nconst config: SanitizedConfig = {} as SanitizedConfig\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 1: Default Editor Config\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you require the default editor config:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const defaultEditorConfig = await editorConfigFactory.default({ config })\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 2: Extract from a Lexical Field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When a lexical field config is available, you can extract the editor config directly:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const fieldEditorConfig = editorConfigFactory.fromField({\\n  field: config.collections[0].fields[1],\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 3: Create a Custom Editor Config\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can create a custom editor configuration by specifying additional features:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { FixedToolbarFeature } from '@payloadcms/richtext-lexical'\\n\\nconst customEditorConfig = await editorConfigFactory.fromFeatures({\\n  config,\\n  features: ({ defaultFeatures }) => [\\n    ...defaultFeatures,\\n    FixedToolbarFeature(),\\n  ],\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Option 4: Extract from an Instantiated Editor\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you've created a global or reusable Lexical editor instance, you can access its configuration. This method is typically less efficient and not recommended:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"const editor = lexicalEditor({\\n  features: ({ defaultFeatures }) => [\\n    ...defaultFeatures,\\n    FixedToolbarFeature(),\\n  ],\\n})\\n\\nconst instantiatedEditorConfig = await editorConfigFactory.fromEditor({\\n  config,\\n  editor,\\n})\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For better efficiency, consider extracting the \", _jsx(_components.code, {\n        children: \"features\"\n      }), \" into a separate variable and using \", _jsx(_components.code, {\n        children: \"fromFeatures\"\n      }), \" instead of this method.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Example - Retrieving the editor config from an existing field\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you have access to the sanitized collection config, you can access the lexical sanitized editor config, as every lexical richText field returns it. Here is an example how you can retrieve it from another field's afterRead hook:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { CollectionConfig, RichTextField } from 'payload'\\n\\nimport {\\n  editorConfigFactory,\\n  getEnabledNodes,\\n  lexicalEditor,\\n} from '@payloadcms/richtext-lexical'\\n\\nexport const MyCollection: CollectionConfig = {\\n  slug: 'slug',\\n  fields: [\\n    {\\n      name: 'text',\\n      type: 'text',\\n      hooks: {\\n        afterRead: [\\n          ({ siblingFields, value }) => {\\n            const field: RichTextField = siblingFields.find(\\n              (field) => 'name' in field && field.name === 'richText',\\n            ) as RichTextField\\n\\n            const editorConfig = editorConfigFactory.fromField({\\n              field,\\n            })\\n\\n            // Now you can use the editor config\\n\\n            return value\\n          },\\n        ],\\n      },\\n    },\\n    {\\n      name: 'richText',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n  ],\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}