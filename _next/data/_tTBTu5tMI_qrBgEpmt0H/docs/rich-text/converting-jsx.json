{"pageProps":{"frontMatter":{"title":"Converting JSX","label":"Converting JSX","order":21,"desc":"Converting between lexical richtext and JSX","keywords":"lexical, richtext, jsx"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\",\n    h3: \"h3\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Richtext to JSX\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To convert richtext to JSX, import the \", _jsx(_components.code, {\n        children: \"RichText\"\n      }), \" component from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/react\"\n      }), \" and pass the richtext content to it:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import React from 'react'\\nimport { RichText } from '@payloadcms/richtext-lexical/react'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\\n  return <RichText data={data} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"RichText\"\n      }), \" component includes built-in converters for common Lexical nodes. You can add or override converters via the \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" prop for custom blocks, custom nodes, or any modifications you need. See the \", _jsx(_components.a, {\n        href: \"https://github.com/payloadcms/payload/blob/main/templates/website/src/components/RichText/index.tsx\",\n        children: \"website template\"\n      }), \" for a working example.\"]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"default\",\n      children: _jsxs(_components.p, {\n        children: [\"When fetching data, ensure your \", _jsx(_components.code, {\n          children: \"depth\"\n        }), \" setting is high enough to fully\\npopulate Lexical nodes such as uploads. The JSX converter requires fully\\npopulated data to work correctly.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Internal Links\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default, Payload doesn't know how to convert \", _jsx(_components.strong, {\n        children: \"internal\"\n      }), \" links to JSX, as it doesn't know what the corresponding URL of the internal link is. You'll notice that you get a \\\"found internal link, but internalDocToHref is not provided\\\" error in the console when you try to render content with internal links.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To fix this, you need to pass the \", _jsx(_components.code, {\n        children: \"internalDocToHref\"\n      }), \" prop to \", _jsx(_components.code, {\n        children: \"LinkJSXConverter\"\n      }), \". This prop is a function that receives the link node and returns the URL of the document.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type {\\n  DefaultNodeTypes,\\n  SerializedLinkNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  LinkJSXConverter,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport React from 'react'\\n\\nconst internalDocToHref = ({ linkNode }: { linkNode: SerializedLinkNode }) => {\\n  const { relationTo, value } = linkNode.fields.doc!\\n  if (typeof value !== 'object') {\\n    throw new Error('Expected value to be an object')\\n  }\\n  const slug = value.slug\\n\\n  switch (relationTo) {\\n    case 'posts':\\n      return `/posts/${slug}`\\n    case 'categories':\\n      return `/category/${slug}`\\n    case 'pages':\\n      return `/${slug}`\\n    default:\\n      return `/${relationTo}/${slug}`\\n  }\\n}\\n\\nconst jsxConverters: JSXConvertersFunction<DefaultNodeTypes> = ({\\n  defaultConverters,\\n}) => ({\\n  ...defaultConverters,\\n  ...LinkJSXConverter({ internalDocToHref }),\\n})\\n\\nexport const MyComponent: React.FC<{\\n  lexicalData: SerializedEditorState\\n}> = ({ lexicalData }) => {\\n  return <RichText converters={jsxConverters} data={lexicalData} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Lexical Blocks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your rich text includes custom Blocks or Inline Blocks, you must supply custom converters that match each block's slug. This converter is not included by default, as Payload doesn't know how to render your custom blocks.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport type { MyInlineBlock, MyNumberBlock, MyTextBlock } from '@/payload-types'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n  SerializedInlineBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport React from 'react'\\n\\n// Extend the default node types with your custom blocks for full type safety\\ntype NodeTypes =\\n  | DefaultNodeTypes\\n  | SerializedBlockNode<MyNumberBlock | MyTextBlock>\\n  | SerializedInlineBlockNode<MyInlineBlock>\\n\\nconst jsxConverters: JSXConvertersFunction<NodeTypes> = ({\\n  defaultConverters,\\n}) => ({\\n  ...defaultConverters,\\n  blocks: {\\n    // Each key should match your block's slug\\n    myNumberBlock: ({ node }) => <div>{node.fields.number}</div>,\\n    myTextBlock: ({ node }) => (\\n      <div style={{ backgroundColor: 'red' }}>{node.fields.text}</div>\\n    ),\\n  },\\n  inlineBlocks: {\\n    // Each key should match your inline block's slug\\n    myInlineBlock: ({ node }) => <span>{node.fields.text}</span>,\\n  },\\n})\\n\\nexport const MyComponent: React.FC<{\\n  lexicalData: SerializedEditorState\\n}> = ({ lexicalData }) => {\\n  return <RichText converters={jsxConverters} data={lexicalData} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Overriding Default JSX Converters\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can override any of the default JSX converters by passing passing your custom converter, keyed to the node type, to the \", _jsx(_components.code, {\n        children: \"converters\"\n      }), \" prop / the converters function.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Example - overriding the upload node converter to use next/image:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedUploadNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  type JSXConvertersFunction,\\n  RichText,\\n} from '@payloadcms/richtext-lexical/react'\\nimport Image from 'next/image'\\nimport React from 'react'\\n\\ntype NodeTypes = DefaultNodeTypes\\n\\n// Custom upload converter component that uses next/image\\nconst CustomUploadComponent: React.FC<{\\n  node: SerializedUploadNode\\n}> = ({ node }) => {\\n  if (node.relationTo === 'uploads') {\\n    const uploadDoc = node.value\\n    if (typeof uploadDoc !== 'object') {\\n      return null\\n    }\\n    const { alt, height, url, width } = uploadDoc\\n    return <Image alt={alt} height={height} src={url} width={width} />\\n  }\\n\\n  return null\\n}\\n\\nconst jsxConverters: JSXConvertersFunction<NodeTypes> = ({\\n  defaultConverters,\\n}) => ({\\n  ...defaultConverters,\\n  // Override the default upload converter\\n  upload: ({ node }) => {\\n    return <CustomUploadComponent node={node} />\\n  },\\n})\\n\\nexport const MyComponent: React.FC<{\\n  lexicalData: SerializedEditorState\\n}> = ({ lexicalData }) => {\\n  return <RichText converters={jsxConverters} data={lexicalData} />\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}