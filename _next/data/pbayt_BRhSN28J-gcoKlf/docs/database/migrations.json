{"pageProps":{"frontMatter":{"title":"Migrations","label":"Migrations","order":20,"keywords":"database, migrations, ddl, sql, mongodb, postgres, documentation, Content Management System, cms, headless, typescript, node, react, nextjs","desc":"Payload features first-party database migrations all done in TypeScript."},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    h2: \"h2\",\n    a: \"a\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Payload exposes a full suite of migration controls available for your use. Migration commands are accessible via\\nthe \", _jsx(_components.code, {\n        children: \"npm run payload\"\n      }), \" command in your project directory.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Ensure you have an npm script called \\\"payload\\\" in your \", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \" file.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-json\",\n        children: \"{\\n  \\\"scripts\\\": {\\n    \\\"payload\\\": \\\"cross-env PAYLOAD_CONFIG_PATH=src/payload.config.ts payload\\\"\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Banner, {\n      children: _jsx(_components.p, {\n        children: \"Note that you need to run Payload migrations through the package manager that\\nyou are using, because Payload should not be globally installed on your\\nsystem.\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Migration file contents\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload stores all created migrations in a folder that you can specify. By default, migrations are stored\\nin \", _jsx(_components.code, {\n        children: \"./src/migrations\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A migration file has two exports - an \", _jsx(_components.code, {\n        children: \"up\"\n      }), \" function, which is called when a migration is executed, and a \", _jsx(_components.code, {\n        children: \"down\"\n      }), \" function\\nthat will be called if for some reason the migration fails to complete successfully. The \", _jsx(_components.code, {\n        children: \"up\"\n      }), \" function should contain\\nall changes that you attempt to make within the migration, and the \", _jsx(_components.code, {\n        children: \"down\"\n      }), \" should ideally revert any changes you make.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is an example migration file:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { MigrateUpArgs, MigrateDownArgs } from '@payloadcms/your-db-adapter'\\n\\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\\n  // Perform changes to your database here.\\n  // You have access to `payload` as an argument, and\\n  // everything is done in TypeScript.\\n}\\n\\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\\n  // Do whatever you need to revert changes if the `up` function fails\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Using Transactions\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When migrations are run, each migration is performed in a new \", _jsx(_components.a, {\n        href: \"/docs/database/transactions\",\n        children: \"transaction\"\n      }), \" for you. All\\nyou need to do is pass the \", _jsx(_components.code, {\n        children: \"req\"\n      }), \" object to any \", _jsx(_components.a, {\n        href: \"/docs/local-api/overview\",\n        children: \"Local API\"\n      }), \" or direct database calls, such as\\n\", _jsx(_components.code, {\n        children: \"payload.db.updateMany()\"\n      }), \", to make database changes inside the transaction. Assuming no errors were thrown, the transaction is committed\\nafter your \", _jsx(_components.code, {\n        children: \"up\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"down\"\n      }), \" function runs. If the migration errors at any point or fails to commit, it is caught and the\\ntransaction gets aborted. This way no change is made to the database if the migration fails.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Using database directly with the transaction\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Additionally, you can bypass Payload's layer entirely and perform operations directly on your underlying database within the active transaction:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"MongoDB:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { type MigrateUpArgs } from '@payloadcms/db-mongodb'\\n\\nexport async function up({\\n  session,\\n  payload,\\n  req,\\n}: MigrateUpArgs): Promise<void> {\\n  const posts = await payload.db.collections.posts.collection\\n    .find({ session })\\n    .toArray()\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Postgres:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\\n\\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\\n  const { rows: posts } = await db.execute(sql`SELECT * from posts`)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"SQLite:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In SQLite, transactions are disabled by default. \", _jsx(_components.a, {\n        href: \"./transactions\",\n        children: \"More\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { type MigrateUpArgs, sql } from '@payloadcms/db-sqlite'\\n\\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\\n  const { rows: posts } = await db.run(sql`SELECT * from posts`)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Migrations Directory\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Each DB adapter has an optional property \", _jsx(_components.code, {\n        children: \"migrationDir\"\n      }), \" where you can override where you want your migrations to be\\nstored/read. If this is not specified, Payload will check the default and possibly make a best effort to find your\\nmigrations directory by searching in common locations ie. \", _jsx(_components.code, {\n        children: \"./src/migrations\"\n      }), \", \", _jsx(_components.code, {\n        children: \"./dist/migrations\"\n      }), \", \", _jsx(_components.code, {\n        children: \"./migrations\"\n      }), \", etc.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All database adapters should implement similar migration patterns, but there will be small differences based on the\\nadapter and its specific needs. Below is a list of all migration commands that should be supported by your database\\nadapter.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Commands\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Migrate\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"migrate\"\n      }), \" command will run any migrations that have not yet been run.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Create\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Create a new migration file in the migrations directory. You can optionally name the migration that will be created. By\\ndefault, migrations will be named using a timestamp.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:create optional-name-here\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Flags:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"--skip-empty\"\n        }), \": with Postgres, it skips the \\\"no schema changes detected. Would you like to create a blank migration file?\\\" prompt which can be useful for generating migration in CI.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"--force-accept-warning\"\n        }), \": accepts any command prompts, creates a blank migration even if there weren't any changes to the schema.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Status\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"migrate:status\"\n      }), \" command will check the status of migrations and output a table of which migrations have been run,\\nand which migrations have not yet run.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"payload migrate:status\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:status\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Down\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Roll back the last batch of migrations.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:down\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Refresh\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Roll back all migrations that have been run, and run them again.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:refresh\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Reset\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Roll back all migrations.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:reset\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Fresh\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Drops all entities from the database and re-runs all migrations from scratch.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \"npm run payload migrate:fresh\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"When to run migrations\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Depending on which Database Adapter you use, your migration workflow might differ subtly.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In relational databases, migrations will be \", _jsx(_components.strong, {\n        children: \"required\"\n      }), \" for non-development database environments. But with MongoDB, you might only need to run migrations once in a while (or never even need them).\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"MongoDB\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In MongoDB, you'll only ever really need to run migrations for times where you change your database shape, and you have lots of existing data that you'd like to transform from Shape A to Shape B.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this case, you can create a migration by running \", _jsx(_components.code, {\n        children: \"pnpm payload migrate:create\"\n      }), \", and then write the logic that you need to perform to migrate your documents to their new shape. You can then either run your migrations in CI before you build / deploy, or you can run them locally, against your production database, by using your production database connection string on your local computer and running the \", _jsx(_components.code, {\n        children: \"pnpm payload migrate\"\n      }), \" command.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Postgres\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In relational databases like Postgres, migrations are a bit more important, because each time you add a new field or a new collection, you'll need to update the shape of your database to match your Payload Config (otherwise you'll see errors upon trying to read / write your data).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That means that Postgres users of Payload should become familiar with the entire migration workflow from top to bottom.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is an overview of a common workflow for working locally against a development database, creating migrations, and then running migrations against your production database before deploying.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"1 - work locally using push mode\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Payload uses Drizzle ORM's powerful \", _jsx(_components.code, {\n        children: \"push\"\n      }), \" mode to automatically sync data changes to your database for you while in development mode. By default, this is enabled and is the suggested workflow to using Postgres and Payload while doing local development.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can disable this setting and solely use migrations to manage your local development database (pass \", _jsx(_components.code, {\n        children: \"push: false\"\n      }), \" to your Postgres adapter), but if you do disable it, you may see frequent errors while running development mode. This is because Payload will have updated to your new data shape, but your local database will not have updated.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For this reason, we suggest that you leave \", _jsx(_components.code, {\n        children: \"push\"\n      }), \" as its default setting and treat your local dev database as a sandbox.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For more information about push mode and prototyping in development, \", _jsx(_components.a, {\n        href: \"./postgres#prototyping-in-development-mode\",\n        children: \"click here\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The typical workflow in Payload is to build out your Payload configs, install plugins, and make progress in development mode - allowing Drizzle to push your changes to your local database for you. Once you're finished, you can create a migration.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But importantly, you do not need to run migrations against your development database, because Drizzle will have already pushed your changes to your database for you.\"\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsx(_components.p, {\n        children: \"Warning: do not mix \\\"push\\\" and migrations with your local development\\ndatabase. If you use \\\"push\\\" locally, and then try to migrate, Payload will\\nthrow a warning, telling you that these two methods are not meant to be used\\ninterchangeably.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"2 - create a migration\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once you're done with working in your Payload Config, you can create a migration. It's best practice to try and complete a specific task or fully build out a feature before you create a migration.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But once you're ready, you can run \", _jsx(_components.code, {\n        children: \"pnpm payload migrate:create\"\n      }), \", which will perform the following steps for you:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"We will look for any existing migrations, and automatically generate SQL changes necessary to convert your schema from its prior state to the new state of your Payload Config\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"We will then create a new migration file in your \", _jsx(_components.code, {\n          children: \"/migrations\"\n        }), \" folder that contains all the SQL necessary to be run\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We won't immediately run this migration for you, however.\"\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsx(_components.p, {\n        children: \"Tip: migrations created by Payload are relatively programmatic in nature, so\\nthere should not be any surprises, but before you check in the created\\nmigration it's a good idea to always double-check the contents of the\\nmigration files.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"3 - set up your build process to run migrations\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Generally, you want to run migrations before you build Payload for production. This typically happens in your CI pipeline and can usually be configured on platforms like Payload Cloud, Vercel, or Netlify by specifying your build script.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A common set of scripts in a \", _jsx(_components.code, {\n        children: \"package.json\"\n      }), \", set up to run migrations in CI, might look like this:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"  \\\"scripts\\\": {\\n    // For running in dev mode\\n    \\\"dev\\\": \\\"next dev --turbo\\\",\\n\\n    // To build your Next + Payload app for production\\n    \\\"build\\\": \\\"next build\\\",\\n\\n    // A \\\"tie-in\\\" to Payload's CLI for convenience\\n    // this helps you run `pnpm payload migrate:create` and similar\\n    \\\"payload\\\": \\\"cross-env NODE_OPTIONS=--no-deprecation payload\\\",\\n\\n    // This command is what you'd set your `build script` to.\\n    // Notice how it runs `payload migrate` and then `pnpm build`?\\n    // This will run all migrations for you before building, in your CI,\\n    // against your production database\\n    \\\"ci\\\": \\\"payload migrate && pnpm build\\\",\\n  },\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the example above, we've specified a \", _jsx(_components.code, {\n        children: \"ci\"\n      }), \" script which we can use as our \\\"build script\\\" in the platform that we are deploying to production with.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This will require that your build pipeline can connect to your database, and it will simply run the \", _jsx(_components.code, {\n        children: \"payload migrate\"\n      }), \" command prior to starting the build process. By calling \", _jsx(_components.code, {\n        children: \"payload migrate\"\n      }), \", Payload will automatically execute any migrations in your \", _jsx(_components.code, {\n        children: \"/migrations\"\n      }), \" folder that have not yet been executed against your production database, in the order that they were created.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If it fails, the deployment will be rejected. But now, with your build script set up to run your migrations, you will be all set! Next time you deploy, your CI will execute the required migrations for you, and your database will be caught up with the shape that your Payload Config requires.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Running migrations in production\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In certain cases, you might want to run migrations at runtime when the server starts. Running them during build time may be impossible due to not having access to your database connection while building or similar reasoning.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you're using a long-running server or container where your Node server starts up one time and then stays initialized, you might prefer to run migrations on server startup instead of within your CI.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to run migrations at runtime, on initialization, you can pass your migrations to your database adapter under the \", _jsx(_components.code, {\n        children: \"prodMigrations\"\n      }), \" key as follows:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"// Import your migrations from the `index.ts` file\\n// that Payload generates for you\\nimport { migrations } from './migrations'\\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // your config here\\n  db: postgresAdapter({\\n    //  your adapter config here\\n    prodMigrations: migrations,\\n  }),\\n})\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Passing your migrations as shown above will tell Payload, in production only, to execute any migrations that need to be run prior to completing the initialization of Payload. This is ideal for long-running services where Payload will only be initialized at startup.\"\n    }), \"\\n\", _jsx(Banner, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Warning:\"\n        }), \" if Payload is instructed to run migrations in production, this\\nmay slow down serverless cold starts on platforms such as Vercel. Generally,\\nthis option should only be used for long-running servers / containers.\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}