{"pageProps":{"frontMatter":{"title":"Converting HTML","label":"Converting HTML","order":22,"desc":"Converting between lexical richtext and HTML","keywords":"lexical, richtext, html"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    h3: \"h3\",\n    code: \"code\",\n    pre: \"pre\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Converting Rich Text to HTML\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two main approaches to convert your Lexical-based rich text to HTML:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Generate HTML on-demand (Recommended)\"\n        }), \": Convert JSON to HTML wherever you need it, on-demand.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Generate HTML within your Collection\"\n        }), \": Create a new field that automatically converts your saved JSON content to HTML. This is not recommended because it adds overhead to the Payload API and may not work well with live preview.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Generating HTML on-demand (Recommended)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To convert JSON to HTML on-demand, use the \", _jsx(_components.code, {\n        children: \"convertLexicalToHTML\"\n      }), \" function from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/html\"\n      }), \". Here's an example of how to use it in a React component in your frontend:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\nimport { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'\\n\\nimport React from 'react'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\\n  const html = convertLexicalToHTML({ data })\\n\\n  return <div dangerouslySetInnerHTML={{ __html: html }} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Converting Lexical Blocks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If your rich text includes Lexical blocks, you need to provide a way to convert them to HTML. For example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { MyInlineBlock, MyTextBlock } from '@/payload-types'\\nimport type {\\n  DefaultNodeTypes,\\n  SerializedBlockNode,\\n  SerializedInlineBlockNode,\\n} from '@payloadcms/richtext-lexical'\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport {\\n  convertLexicalToHTML,\\n  type HTMLConvertersFunction,\\n} from '@payloadcms/richtext-lexical/html'\\nimport React from 'react'\\n\\ntype NodeTypes =\\n  | DefaultNodeTypes\\n  | SerializedBlockNode<MyTextBlock>\\n  | SerializedInlineBlockNode<MyInlineBlock>\\n\\nconst htmlConverters: HTMLConvertersFunction<NodeTypes> = ({\\n  defaultConverters,\\n}) => ({\\n  ...defaultConverters,\\n  blocks: {\\n    // Each key should match your block's slug\\n    myTextBlock: ({ node, providedCSSString }) =>\\n      `<div style=\\\"background-color: red;${providedCSSString}\\\">${node.fields.text}</div>`,\\n  },\\n  inlineBlocks: {\\n    // Each key should match your inline block's slug\\n    myInlineBlock: ({ node, providedStyleTag }) =>\\n      `<span${providedStyleTag}>${node.fields.text}</span$>`,\\n  },\\n})\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\\n  const html = convertLexicalToHTML({\\n    converters: htmlConverters,\\n    data,\\n  })\\n\\n  return <div dangerouslySetInnerHTML={{ __html: html }} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Outputting HTML from the Collection\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To automatically generate HTML from the saved richText field in your Collection, use the \", _jsx(_components.code, {\n        children: \"lexicalHTMLField()\"\n      }), \" helper. This approach converts the JSON to HTML using an \", _jsx(_components.code, {\n        children: \"afterRead\"\n      }), \" hook. For instance:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { HTMLConvertersFunction } from '@payloadcms/richtext-lexical/html'\\nimport type { MyTextBlock } from '@/payload-types.js'\\nimport type { CollectionConfig } from 'payload'\\n\\nimport {\\n  BlocksFeature,\\n  type DefaultNodeTypes,\\n  lexicalEditor,\\n  lexicalHTMLField,\\n  type SerializedBlockNode,\\n} from '@payloadcms/richtext-lexical'\\n\\nconst Pages: CollectionConfig = {\\n  slug: 'pages',\\n  fields: [\\n    {\\n      name: 'nameOfYourRichTextField',\\n      type: 'richText',\\n      editor: lexicalEditor(),\\n    },\\n    lexicalHTMLField({\\n      htmlFieldName: 'nameOfYourRichTextField_html',\\n      lexicalFieldName: 'nameOfYourRichTextField',\\n    }),\\n    {\\n      name: 'customRichText',\\n      type: 'richText',\\n      editor: lexicalEditor({\\n        features: ({ defaultFeatures }) => [\\n          ...defaultFeatures,\\n          BlocksFeature({\\n            blocks: [\\n              {\\n                interfaceName: 'MyTextBlock',\\n                slug: 'myTextBlock',\\n                fields: [\\n                  {\\n                    name: 'text',\\n                    type: 'text',\\n                  },\\n                ],\\n              },\\n            ],\\n          }),\\n        ],\\n      }),\\n    },\\n    lexicalHTMLField({\\n      htmlFieldName: 'customRichText_html',\\n      lexicalFieldName: 'customRichText',\\n      // can pass in additional converters or override default ones\\n      converters: (({ defaultConverters }) => ({\\n        ...defaultConverters,\\n        blocks: {\\n          myTextBlock: ({ node, providedCSSString }) =>\\n            `<div style=\\\"background-color: red;${providedCSSString}\\\">${node.fields.text}</div>`,\\n        },\\n      })) as HTMLConvertersFunction<\\n        DefaultNodeTypes | SerializedBlockNode<MyTextBlock>\\n      >,\\n    }),\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Generating HTML in Your Frontend with Dynamic Population (Advanced)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default, \", _jsx(_components.code, {\n        children: \"convertLexicalToHTML\"\n      }), \" expects fully populated data (e.g. uploads, links, etc.). If you need to dynamically fetch and populate those nodes, use the async variant, \", _jsx(_components.code, {\n        children: \"convertLexicalToHTMLAsync\"\n      }), \", from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical/html-async\"\n      }), \". You must provide a \", _jsx(_components.code, {\n        children: \"populate\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"'use client'\\n\\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { getRestPopulateFn } from '@payloadcms/richtext-lexical/client'\\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\\nimport React, { useEffect, useState } from 'react'\\n\\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\\n  const [html, setHTML] = useState<null | string>(null)\\n  useEffect(() => {\\n    async function convert() {\\n      const html = await convertLexicalToHTMLAsync({\\n        data,\\n        populate: getRestPopulateFn({\\n          apiURL: `http://localhost:3000/api`,\\n        }),\\n      })\\n      setHTML(html)\\n    }\\n\\n    void convert()\\n  }, [data])\\n\\n  return html && <div dangerouslySetInnerHTML={{ __html: html }} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Using the REST populate function will send a separate request for each node. If you need to populate a large number of nodes, this may be slow. For improved performance on the server, you can use the \", _jsx(_components.code, {\n        children: \"getPayloadPopulateFn\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-tsx\",\n        children: \"import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\\n\\nimport { getPayloadPopulateFn } from '@payloadcms/richtext-lexical'\\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\\nimport { getPayload } from 'payload'\\nimport React from 'react'\\n\\nimport config from '../../config.js'\\n\\nexport const MyRSCComponent = async ({\\n  data,\\n}: {\\n  data: SerializedEditorState\\n}) => {\\n  const payload = await getPayload({\\n    config,\\n  })\\n\\n  const html = await convertLexicalToHTMLAsync({\\n    data,\\n    populate: await getPayloadPopulateFn({\\n      currentDepth: 0,\\n      depth: 1,\\n      payload,\\n    }),\\n  })\\n\\n  return html && <div dangerouslySetInnerHTML={{ __html: html }} />\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Converting HTML to Richtext\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you need to convert raw HTML into a Lexical editor state, use \", _jsx(_components.code, {\n        children: \"convertHTMLToLexical\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"@payloadcms/richtext-lexical\"\n      }), \", along with the \", _jsx(_components.a, {\n        href: \"/docs/rich-text/converters#retrieving-the-editor-config\",\n        children: \"editorConfigFactory to retrieve the editor config\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import {\\n  convertHTMLToLexical,\\n  editorConfigFactory,\\n} from '@payloadcms/richtext-lexical'\\n// Make sure you have jsdom and @types/jsdom installed\\nimport { JSDOM } from 'jsdom'\\n\\nconst html = convertHTMLToLexical({\\n  editorConfig: await editorConfigFactory.default({\\n    config, // Your Payload Config\\n  }),\\n  html: '<p>text</p>',\\n  JSDOM, // Pass in the JSDOM import; it's not bundled to keep package size small\\n})\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}