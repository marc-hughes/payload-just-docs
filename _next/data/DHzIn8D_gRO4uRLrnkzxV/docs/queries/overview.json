{"pageProps":{"frontMatter":{"title":"Querying your Documents","label":"Overview","order":10,"desc":"Payload provides a querying language through all APIs, allowing you to filter or search through documents within a Collection.","keywords":"query, documents, overview, documentation, Content Management System, cms, headless, javascript, node, react, nextjs"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    strong: \"strong\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components), {Banner} = _components;\n  if (!Banner) _missingMdxReference(\"Banner\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In Payload, \\\"querying\\\" means filtering or searching through Documents within a \", _jsx(_components.a, {\n        href: \"../configuration/collections\",\n        children: \"Collection\"\n      }), \". The querying language in Payload is designed to be simple and powerful, allowing you to filter Documents with extreme precision through an intuitive and standardized structure.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Payload provides three common APIs for querying your data:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/local-api/overview\",\n          children: \"Local API\"\n        }), \" - Extremely fast, direct-to-database access\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/rest-api/overview\",\n          children: \"REST API\"\n        }), \" - Standard HTTP endpoints for querying and mutating data\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"/docs/graphql/overview\",\n          children: \"GraphQL\"\n        }), \" - A full GraphQL API with a GraphQL Playground\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Each of these APIs share the same underlying querying language, and fully support all of the same features. This means that you can learn Payload's querying language once, and use it across any of the APIs that you might use.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To query your Documents, you can send any number of \", _jsx(_components.a, {\n        href: \"#operators\",\n        children: \"Operators\"\n      }), \" through your request:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  color: {\\n    equals: 'blue',\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.em, {\n        children: [\"The exact query syntax will depend on the API you are using, but the concepts are the same across all APIs. \", _jsx(_components.a, {\n          href: \"#writing-queries\",\n          children: \"More details\"\n        }), \".\"]\n      })\n    }), \"\\n\", _jsx(Banner, {\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" You can also use queries within \", _jsx(_components.a, {\n          href: \"../access-control/overview\",\n          children: \"Access\\nControl\"\n        }), \" functions.\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Operators\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The following operators are available for use in queries:\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Operator\"\n          }), _jsx(_components.th, {\n            children: \"Description\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"equals\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must be exactly equal.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"not_equals\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The query will return all documents where the value is not equal.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"greater_than\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"greater_than_equal\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"less_than\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"less_than_equal\"\n            })\n          }), _jsx(_components.td, {\n            children: \"For numeric or date-based fields.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"like\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Case-insensitive string must be present. If string of words, all words must be present, in any order.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"contains\"\n            })\n          }), _jsx(_components.td, {\n            children: \"Must contain the value entered, case-insensitive.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"in\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must be found within the provided comma-delimited list of values.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"not_in\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must NOT be within the provided comma-delimited list of values.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"all\"\n            })\n          }), _jsx(_components.td, {\n            children: \"The value must contain all values provided in the comma-delimited list. Note: currently this operator is supported only with the MongoDB adapter.\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"exists\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"Only return documents where the value either exists (\", _jsx(_components.code, {\n              children: \"true\"\n            }), \") or does not exist (\", _jsx(_components.code, {\n              children: \"false\"\n            }), \").\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"near\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For distance related to a \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Field\"\n            }), \" comma separated as \", _jsx(_components.code, {\n              children: \"<longitude>, <latitude>, <maxDistance in meters (nullable)>, <minDistance in meters (nullable)>\"\n            }), \".\"]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"within\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Fields\"\n            }), \" to filter documents based on whether points are inside of the given area defined in GeoJSON. \", _jsx(_components.a, {\n              href: \"../fields/point#querying-within\",\n              children: \"Example\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: _jsx(_components.code, {\n              children: \"intersects\"\n            })\n          }), _jsxs(_components.td, {\n            children: [\"For \", _jsx(_components.a, {\n              href: \"../fields/point\",\n              children: \"Point Fields\"\n            }), \" to filter documents based on whether points intersect with the given area defined in GeoJSON. \", _jsx(_components.a, {\n              href: \"../fields/point#querying-intersects\",\n              children: \"Example\"\n            })]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(Banner, {\n      type: \"success\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Tip:\"\n        }), \" If you know your users will be querying on certain fields a lot, add\\n\", _jsx(_components.code, {\n          children: \"index: true\"\n        }), \" to the Field Config. This will speed up searches using that\\nfield immensely.\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"And / Or Logic\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In addition to defining simple queries, you can join multiple queries together using AND / OR logic. These can be nested as deeply as you need to create complex queries.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To join queries, use the \", _jsx(_components.code, {\n        children: \"and\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"or\"\n      }), \" keys in your query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  or: [\\n    // highlight-line\\n    {\\n      color: {\\n        equals: 'mint',\\n      },\\n    },\\n    {\\n      and: [\\n        // highlight-line\\n        {\\n          color: {\\n            equals: 'white',\\n          },\\n        },\\n        {\\n          featured: {\\n            equals: false,\\n          },\\n        },\\n      ],\\n    },\\n  ],\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Written in plain English, if the above query were passed to a \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" operation, it would translate to finding posts where either the \", _jsx(_components.code, {\n        children: \"color\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"mint\"\n      }), \" OR the \", _jsx(_components.code, {\n        children: \"color\"\n      }), \" is \", _jsx(_components.code, {\n        children: \"white\"\n      }), \" AND \", _jsx(_components.code, {\n        children: \"featured\"\n      }), \" is set to false.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Nested properties\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When working with nested properties, which can happen when using relational fields, it is possible to use the dot notation to access the nested property. For example, when working with a \", _jsx(_components.code, {\n        children: \"Song\"\n      }), \" collection that has a \", _jsx(_components.code, {\n        children: \"artists\"\n      }), \" field which is related to an \", _jsx(_components.code, {\n        children: \"Artists\"\n      }), \" collection using the \", _jsx(_components.code, {\n        children: \"name: 'artists'\"\n      }), \". You can access a property within the collection \", _jsx(_components.code, {\n        children: \"Artists\"\n      }), \" like so:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-js\",\n        children: \"import type { Where } from 'payload'\\n\\nconst query: Where = {\\n  'artists.featured': {\\n    // nested property name to filter on\\n    exists: true, // operator to use and boolean value that needs to be true\\n  },\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Writing Queries\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Writing queries in Payload is simple and consistent across all APIs, with only minor differences in syntax between them.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Local API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"../local-api/overview\",\n        children: \"Local API\"\n      }), \" supports the \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" operation that accepts a raw query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import type { Payload } from 'payload'\\n\\nconst getPosts = async (payload: Payload) => {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    where: {\\n      color: {\\n        equals: 'mint',\\n      },\\n    },\\n  })\\n\\n  return posts\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"GraphQL API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All \", _jsx(_components.code, {\n        children: \"find\"\n      }), \" queries in the \", _jsx(_components.a, {\n        href: \"../graphql/overview\",\n        children: \"GraphQL API\"\n      }), \" support the \", _jsx(_components.code, {\n        children: \"where\"\n      }), \" argument that accepts a raw query object:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"query {\\n  Posts(where: { color: { equals: mint } }) {\\n    docs {\\n      color\\n    }\\n    totalDocs\\n  }\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"REST API\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With the \", _jsx(_components.a, {\n        href: \"../rest-api/overview\",\n        children: \"REST API\"\n      }), \", you can use the full power of Payload queries, but they are written as query strings instead:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"https://localhost:3000/api/posts?where[color][equals]=mint\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To understand the syntax, you need to understand that complex URL search strings are parsed into a JSON object. This one isn't too bad, but more complex queries get unavoidably more difficult to write.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For this reason, we recommend to use the extremely helpful and ubiquitous \", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/qs-esm\",\n        children: _jsx(_components.code, {\n          children: \"qs-esm\"\n        })\n      }), \" package to parse your JSON / object-formatted queries into query strings:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-ts\",\n        children: \"import { stringify } from 'qs-esm'\\nimport type { Where } from 'payload'\\n\\nconst query: Where = {\\n  color: {\\n    equals: 'mint',\\n  },\\n  // This query could be much more complex\\n  // and qs-esm would handle it beautifully\\n}\\n\\nconst getPosts = async () => {\\n  const stringifiedQuery = stringify(\\n    {\\n      where: query, // ensure that `qs-esm` adds the `where` property, too!\\n    },\\n    { addQueryPrefix: true },\\n  )\\n\\n  const response = await fetch(\\n    `http://localhost:3000/api/posts${stringifiedQuery}`,\\n  )\\n  // Continue to handle the response below...\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}